var documenterSearchIndex = {"docs":
[{"location":"functionindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"functionindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"functionindex/","page":"Index","title":"Index","text":"Modules = [Thebes]\nOrder   = [:function, :type]","category":"page"},{"location":"functionindex/#Luxor.between","page":"Index","title":"Luxor.between","text":"between(p1::Point3D, p2::Point3D, x=0.5)\nbetween((p1::Point3D, p2::Point3D), x=0.5)\n\nFind a point on a line between two 3D points. If x is 0.5, the returned point should be halfway between them.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Luxor.distance-Tuple{Point3D,Point3D}","page":"Index","title":"Luxor.distance","text":"distance(p1::Point3D, p2::Point3D)\n\nReturn the distance between two points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Luxor.midpoint-Tuple{Point3D,Point3D}","page":"Index","title":"Luxor.midpoint","text":"midpoint(pt1::Point3D, pt2::Point3D)\n\nFind the midpoint between two points. See also between().\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.anglebetweenvectors-Tuple{Point3D,Point3D}","page":"Index","title":"Thebes.anglebetweenvectors","text":"anglebetweenvectors(v1::Point3D, v2::Point3D)\n\nCalclate the angle between two vectors.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.axes3D","page":"Index","title":"Thebes.axes3D","text":"axes3D(n=100)\n\nDraw labelled 3D axes at (0, 0, 0) with length n.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.carpet","page":"Index","title":"Thebes.carpet","text":"carpet(n; kind=:circular)\n\nDraw a circular carpet centered at the origin, using current Luxor parameters.\n\nIf kind is not :circular, the carpet will be a square.\n\nPoints that can't be rendered are not included in the final shape.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.cartesiantospherical-Tuple{Any,Any,Any}","page":"Index","title":"Thebes.cartesiantospherical","text":"cartesiantospherical(x, y, z)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of the Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.centerpoint-Tuple{}","page":"Index","title":"Thebes.centerpoint","text":"centerpoint()\ncenterpoint(pt::Point3D)\n\nGet or set the current center position.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.crossproduct3D-Tuple{Point3D,Point3D}","page":"Index","title":"Thebes.crossproduct3D","text":"crossproduct3D(A::Point3D, B::Point3D)\n\nFind one of these.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.dotproduct3D-Tuple{Point3D,Point3D}","page":"Index","title":"Thebes.dotproduct3D","text":"dotproduct3D(a::Point3D, b::Point3D)\n\nFinds the dot product of a and b\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.drawcube","page":"Index","title":"Thebes.drawcube","text":"drawcube(n=10, action=:stroke)\n\nDraw a cube. drawcube(1) draws a wireframe unit cube.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.eyepoint-Tuple{}","page":"Index","title":"Thebes.eyepoint","text":"eyepoint()\neyepoint(pt::Point3D)\n\nGet or set the current eye position.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.face-Tuple{Object,Any}","page":"Index","title":"Thebes.face","text":"face(o::Object, n)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.helloworld-Tuple{}","page":"Index","title":"Thebes.helloworld","text":"helloworld()\n\nReset all the things. The equivalent of typing:\n\neyepoint(100, 100, 100)\ncenterpoint(0, 0, 0)\nuppoint(0, 0, 10)\nperspective(0)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.magnitude-Tuple{Point3D}","page":"Index","title":"Thebes.magnitude","text":"magnitude(a::Point3D)\n\nCalculates magnitude of a.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.make","page":"Index","title":"Thebes.make","text":"make(primitive, name=\"unnamed\")\n\nprimitive contains two arrays, an array of 3D points, and an array of faces, where each face is a list of vertex numbers.\n\nReturns a Object.\n\nExample\n\nmake(Cube, \"cube\")\n\nreturns an Object object containing an array of vertices, an array of faces, and an array of labels.\n\n@draw begin\n    helloworld()\n    tol = 0.01\n    a = []\n    sethue(\"black\")\n    for t in -2pi:tol:2pi\n        push!(a, Point3D((50 + cos(5t)) * cos(3t), (50 + cos(5t)) * sin(2t), sin(5t)))\n    end\n    Knot = make((a, []), \"knot\")\n    pin(Knot, gfunction = (args...) -> poly(args[1], :stroke))\nend\n\nThe default gfunction expects faces - if there aren't any, use a gfunction that draws vertices.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.moveby!-Tuple{Array{Point3D,1},Point3D}","page":"Index","title":"Thebes.moveby!","text":"moveby!(ptlist::Point3D, x, y, z)\nmoveby!(ptlist::Point3D, pt::Point3D)\n\nMove all points in the list by a vector.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby!-Tuple{Object,Any,Any,Any}","page":"Index","title":"Thebes.moveby!","text":"moveby!(o::Object, x, y, z)\nmoveby!(o::Object, pt::Point3D)\n\nSet the position of object to Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby-Tuple{Object,Any,Any,Any}","page":"Index","title":"Thebes.moveby","text":"moveby(o::Object, x, y, z)\nmoveby(o::Object, pt::Point3D)\n\nSet the position of a copy of the object to Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby-Tuple{Point3D,Point3D}","page":"Index","title":"Thebes.moveby","text":"moveby(pt::Point3D, d::Point3D)\n\nReturn a new point that's the result of moving a point pt by a vector d.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.newprojection","page":"Index","title":"Thebes.newprojection","text":"newprojection(ipos::Point3D, center::Point3D, up::Point3D, perspective=0.0)\n\nDefine a new Projection:\n\nipos is the eye position\ncenter is the 3D point to appear in the center of the 2D image\nup is a point that is to appear vertically above the center\n\nIf perspective is 0.0 (the default) the projection is parallel. Otherwise it's a vague magnification factor for perspective projections.\n\nThe three vectors U, V, W, and the three scalar products, ue, ve, and we:\n\nu is at right angles to line of sight w, and to t-e, so it corresponds to\n\nthe x axis of the 2D image\n\nv is at right angles to u and to the line of sight, so it's the y axis of the\n\n2D image\n\nw is the line of sight\nwe is the projection of the eye position onto w\nue is the projection of the eye position onto that x-axis\nve is the projection of the eye position onto that y axis\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.objecttopoly-Tuple{Object}","page":"Index","title":"Thebes.objecttopoly","text":"objecttopoly(o::Object)\n\nReturn a tuple:\n\nan array of 2D points representing the vertices of o\nan array of 2D polygons representing the faces of o\n\nExample\n\nThis example draws the faces of a cube in colors, and marks the vertices in black.\n\nusing Luxor, Thebes\n\n@draw begin\n    helloworld()\n    o = make(Cube)\n    scaleby!(o, 100, 100, 100)\n    vs, fs = objecttopoly(o)\n    setopacity(0.4)\n    sethue(\"black\")\n    for face in fs\n        randomhue()\n        poly(face, :fill)\n    end\n    sethue(\"black\")\n    circle.(vs, 3, :fill)\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.perspective-Tuple{}","page":"Index","title":"Thebes.perspective","text":"perspective()\nperspective(n)\n\nGet or set the current  perspective.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Array{Point3D,1}}","page":"Index","title":"Thebes.pin","text":"pin(p3list::Array{Point3D, 1};\n    gfunction = (p3list, p2list) ->\n        poly(p2list, :stroke, close=true))\n\nDraw an array of 3D points.\n\nThe default action is to draw a polygon through all the points.\n\nThe gfunction can access the 3D points as the first argument, the two 2D points in the second argument.\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 20θ) for θ in 0:π/12:4π]\na_box = pin(helix, gfunction =\n    (p3list, p2list) -> prettypoly(p2list, :stroke)\n    )\n\nReturns the list of 2D points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Object}","page":"Index","title":"Thebes.pin","text":"pin(o::Object;\n    gfunction=(o) -> hiddensurface(o))\n\nDraw a rendering of an object.\n\nThe default rendering function is hiddensurface().\n\nYou can also use the built-in wireframe() rendering function.\n\nExamples\n\n@draw begin\n    o = make(Cube)\n    axes3D(200)\n    scaleby!(o, 200, 200, 200)\n    eyepoint(250, 270, 300)\n    pin(o) # use an attempted hiddensurface rendering\n\n    o = make(Tetrahedron)\n    axes3D(200)\n    scaleby!(o, 200, 200, 200)\n    eyepoint(250, 270, 300)\n    pin(o, gfunction=wireframe) # use a wireframe rendering\nend\n\nMore help\n\nYou could write your own rendering function to draw objects.\n\nfunction a_rendering_function(o::Object)\n   if !isempty(o.faces)\n       sortfaces!(o)\n       @layer begin\n           for (n, face) in enumerate(o.faces)\n               @layer begin\n                   vertices = o.vertices[face]\n                   sn = surfacenormal(vertices)\n                   ang = anglebetweenvectors(sn, eyepoint())\n                   setgrey(rescale(ang, 0, π, 1, 0))\n                   pin(vertices, gfunction = (p3, p2) ->\n                    begin\n                       poly(p2, :fill)\n                       sethue(\"white\")\n                       poly(p2, :stroke, close=true)\n                    end)\n               end\n           end\n       end\n   end\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Point3D,Point3D}","page":"Index","title":"Thebes.pin","text":"pin(p3_1::Point3D, p3_2::Point3D;\n    gfunction = ((p3_1, p3_2), (p2_1, p2_2)) ->\n        line(p2_1, p2_2, :stroke))\n\nDraw two 3D points.\n\nThe default action is to draw a line between two points.\n\nThe gfunction can access the 3D points as the first argument, the two 2D points in the second argument.\n\npin(p, Point3D(50cos(θ), 50sin(θ), p.z),\n    gfunction = (p3s, p2s) -> begin\n        line(p2s..., :stroke)\n    end)\n\n\nReturns the two 2D points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Point3D}","page":"Index","title":"Thebes.pin","text":"pin(pt::Point3D;\n    gfunction = (p3, p2) -> circle(p2, 1, :stroke))\n\nDraw a single 3D point on the current Luxor drawing.\n\nThe default graphic is a circle. You can define others using a custom gfunction, which takes two arguments: the 3D point and its 2D counterpoint.\n\nFor example, this draws a circle whose radius is larger if the point is nearer to the eye.\n\npin(p, gfunction = (p3, p2) -> begin\n        d = distance(p3, eyepoint())\n        circle(p2, rescale(d, 0, 300, 20, 5), :fill)\n    end\n    )\n\nReturns the 2D point.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pointsperpendicular","page":"Index","title":"Thebes.pointsperpendicular","text":"pointsperpendicular(p1::Point3D, p2::Point3D, radius, angles = [0, π])\n\nFind points perpendicular to a line joining p1 and p2. Points are radius units away from the line.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.project-Tuple{Point3D}","page":"Index","title":"Thebes.project","text":"project(P::Point3D)\n\nProject a 3D point onto a 2D surface, as defined by the current projection.\n\nTODO Currently this returns 'nothing' if the point is behind the eyepoint. This makes handling the conversion a bit harder, though, since the function now returns either a 2D Luxor point or nothing.\n\nusing Thebes, Luxor\n\n@svg begin\n    eyepoint(Point3D(250, 250, 100))\n    centerpoint(Point3D(0, 0, 0))\n    uppoint(Point3D(0, 0, 10))\n    sethue(\"grey50\")\n    carpet(300)\n    axes3D(100)\n    sethue(\"red\")\n    for i in 1:30\n        randpoint3D = Point3D(rand(0.0:150, 3)...)\n        sethue(\"red\")\n        pt1 = pin(randpoint3D)\n        if pt1 != nothing\n            circle(pt1, 5, :fill)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateX-Tuple{Point3D,Any}","page":"Index","title":"Thebes.rotateX","text":"rotateX(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the x axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateY-Tuple{Point3D,Any}","page":"Index","title":"Thebes.rotateY","text":"rotateY(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the y axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateZ-Tuple{Point3D,Any}","page":"Index","title":"Thebes.rotateZ","text":"rotateZ(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the z axis by an angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Array{Point3D,1},Float64,Float64,Float64}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\n\nModify a list of points by rotating each one around the x, y, and z axes by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Array{Point3D,1},Point3D,Float64,Float64,Float64}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(ptlist::Array{Point3D, 1}, r::Rotation=RotXYZ{Float64})\n\nRotate each point in the list by rotation (or angleX, angleY, angleZ) around another point (or origin).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Object,Any,Any,Any}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(o::Object, r::Rotation)\nrotateby!(o::Object, angleX, angleY, angleZ)\n\nRotate an object through rotation r, or around the x, y, and/or z axis by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Object,Point3D,Any,Any,Any}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby!(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate an object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Object,Any,Any,Any}","page":"Index","title":"Thebes.rotateby","text":"rotateby(o::Object, angleX, angleY, angleZ)\n\nRotate a copy of the object by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Object,Point3D,Any,Any,Any}","page":"Index","title":"Thebes.rotateby","text":"rotateby(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate a copy of the object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Point3D,Float64,Float64,Float64}","page":"Index","title":"Thebes.rotateby","text":"rotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(point::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\n\nReturn a new point/list of points resulting from rotating around the x, y, and z axes by angleX, angleY, angleZ.\n\nThe Z rotation is first, then the Y, then the X.\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XYZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Point3D,Point3D,Float64,Float64,Float64}","page":"Index","title":"Thebes.rotateby","text":"rotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.scaleby!-Tuple{Array{Point3D,1},Any,Any,Any}","page":"Index","title":"Thebes.scaleby!","text":"scaleby!(ptlist::Array{Point3D, 1}, x, y, z)\n\nScales a list of points by multiplying by x in X, y in Y, z in Z.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.scaleby!-Tuple{Object,Any,Any,Any}","page":"Index","title":"Thebes.scaleby!","text":"scaleby!(o::Object, x, y, z)\n\nScale object by x in x, y in y, and z in z.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.sortfaces!-Tuple{Object}","page":"Index","title":"Thebes.sortfaces!","text":"sortfaces!(o::Object;\n    eyepoint::Point3D=eyepoint())\n\nFind the averages of the z values of the faces in Object, and sort the faces of o so that the faces are in order of nearest (highest) z relative to eyepoint...\n\nor something like that ? not sure how this works\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.sphericaltocartesian-Tuple{Any,Any,Any}","page":"Index","title":"Thebes.sphericaltocartesian","text":"sphericaltocartesian(ρ, θ, ϕ)\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ):\n\nρ is the distance from the origin (ie radius)\nθ is the azimuthal angle (the longitude) 0 is +x, π is -x, 2π is +x\nϕ is the polar angle (the latitude) 0 is North Pole, π is South Pole\n\nThere are two major conventions for spherical coordinate notation.\n\nIn physics books:\n\n(ρ, θ, φ) gives the radial distance, polar angle (latitude), and azimuthal angle (longitude)\n\nIn mathematics books:\n\n(ρ, θ , φ ) gives the radial distance, azimuthal angle (longitude), and polar angle (latitude)\n\nSo we're using the mathematics one here.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.surfacenormal-Tuple{Array{Point3D,1}}","page":"Index","title":"Thebes.surfacenormal","text":"surfacenormal(ptlist::Array{Point3D, 1})\n\nFinds one of these.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.text3D-Tuple{Any,Point3D}","page":"Index","title":"Thebes.text3D","text":" text3D(str, anchor::Point3D;\n    halign=:left,\n    valign=:baseline,\n    about=Point3D(0., 0., 0.),\n    rotation::Rotation=RotXYZ(0, 0, 0))\n\nDraw text at point pt, lying in the plane of the x axis. Angles in rotation rotate the text about the about point, defaulting to Point3D(0, 0, 0).\n\nUses Luxor's fontface() and fontsize() settings.\n\nSpecify rotations using functions from Rotations.jl, such as:\n\nRotX(a)\nRotZ(a)\nRotXZ(a1, a2)\nRotXYZ(a1, a2, a3)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.uppoint-Tuple{Point3D}","page":"Index","title":"Thebes.uppoint","text":"uppoint(pt::Point3D)\n\nSpecify the \"up\" direction for the world: a line from the centerpoint to the uppoint defines the up direction.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.uppoint-Tuple{}","page":"Index","title":"Thebes.uppoint","text":"uppoint()\nuppoint(pt::Point3D)\n\nGet or set the current eye position.\n\n\n\n\n\n","category":"method"},{"location":"objects/","page":"Objects","title":"Objects","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"objects/#Objects","page":"Objects","title":"Objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"So far we've been drawing individual points and lines. This gets tiresome when you have a lot of them. Fortunately, Thebes has a few features for handling larger groups of points.","category":"page"},{"location":"objects/#Making-objects","page":"Objects","title":"Making objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"You make a 3D object using make(), and then use pin() to throw it onto the 2D drawing.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"make() expects an array of 3D points, an (optional) array of face definitions, and an (optional) array of labels, plus an (optional) name. These arrays let you link faces with vertices. It returns an Object.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"A Cube object is already defined in Thebes (we needn't have made one earlier, really). So after:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"cube = make(Cube, \"cube\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"the cube variable contains:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Object(\n    Point3D[\n        Point3D(-0.5, 0.5, -0.5),\n        Point3D(0.5, 0.5, -0.5),\n        Point3D(0.5, -0.5, -0.5),\n        Point3D(-0.5, -0.5, -0.5),\n        Point3D(-0.5, 0.5, 0.5),\n        Point3D(0.5, 0.5, 0.5),\n        Point3D(0.5, -0.5, 0.5),\n        Point3D(-0.5, -0.5, 0.5)\n    ],\n\n    [[1, 2, 3, 4],\n     [2, 6, 7, 3],\n     [6, 5, 8, 7],\n     [5, 1, 4, 8],\n     [1, 5, 6, 2],\n     [4, 3, 7, 8]],\n\n     [1, 2, 3, 4, 5, 6],\n\n     \"cube\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The default rendering applied by pin() is an attempt at a simple hidden-surface display. In real 3D software, this process has to be far more sophisticated.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/simplecubeobject.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nhelloworld() # hide\n\neyepoint(10, 10, 10)\nperspective(3000)\ncube = make(Cube, \"cube\")\npin(cube)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: simple cube object)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's a very simple example of how you might make your own object from scratch.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/object1.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nhelloworld() # hide\n\ntol = 0.001\na = Point3D[]\nfor t in -2pi:tol:2pi\n    push!(a, Point3D((100 + cos(5t)) * cos(3t), (100 + cos(5t)) * sin(2t), sin(5t)))\nend\nsethue(\"darkorange\")\nknot = make([a, []], \"knot\")\n\npin(knot, gfunction = (o) -> poly(objecttopoly(o)[1], :stroke))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: point example)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The objecttopoly() function returns a tuple, containing the 2D vertices, and the polygons that define the faces.","category":"page"},{"location":"objects/#OFF-the-shelf-objects","page":"Objects","title":"OFF the shelf objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"Obviously this isn't something you'd want to do \"by hand\" very often. Fortunately there are plenty of people who are prepared to make 3D objects and distribute them in standard file formats, via the internet. Thebes.jl knows about one of these formats, the Object File Format (.OFF). So there are a few objects already available for you to use directly.","category":"page"},{"location":"objects/#Using-objects","page":"Objects","title":"Using objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"The following objects are preloaded (from data/objects.jl) when Thebes.jl starts:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Cube\nTetrahedron\nPyramid\nTeapot","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\nDrawing(800, 300, \"assets/figures/moreobjects.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nhelloworld() # hide\n\nt = Tiler(600, 300, 2, 2)\nsetline(0.5)\nfor (n, o) in enumerate([Cube, Tetrahedron, Pyramid, Teapot])\n    @layer begin\n        translate(first.(t)[n])\n        object = make(o, string(o))\n        scaleby!(object, 80, 80, 80)\n        pin(object)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: more objects)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\nDrawing(800, 300, \"assets/figures/teapot.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nhelloworld()\naxes3D(200)\nteapot = make(Teapot)\nsetline(0.5)\nscaleby!(teapot, 100, 100, 100)\npin(teapot, gfunction=wireframe)\nfinish() # hide\nnothing # hide\n","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: teapot)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"You can load a few more objects by including the moreobjects.jl file:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"include(dirname(dirname(pathof(Thebes))) * \"/data/moreobjects.jl\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"which brings these objects into play:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"boxcube boxtorus concave cone crossshape cube cuboctahedron dodecahedron geodesic helix2 icosahedron icosidodecahedron octahedron octtorus rhombicosidodecahedron rhombicuboctahedron rhombitruncated_cubeoctahedron rhombitruncated_icosidodecahedron snub_cube snub_dodecahedron sphere2 tet3d tetrahedron triangle truncated_cube truncated_dodecahedron truncated_icosahedron truncated_octahedron truncated_tetrahedron","category":"page"},{"location":"objects/#Rendering-objects","page":"Objects","title":"Rendering objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"To render objects, there are many choices you can make about how to draw the faces and the vertices.","category":"page"},{"location":"objects/#Using-gfunctions","page":"Objects","title":"Using gfunctions","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"You do this with a gfunction.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's a simple example:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n\ninclude(dirname(pathof(Thebes)) * \"/../data/moreobjects.jl\")\n\nDrawing(600, 600, \"assets/figures/geodesic.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nhelloworld() # hide\nsetlinejoin(\"bevel\")\neyepoint(150, 150, 150)\n\nfunction mygfunction(o::Object)\n    cols = [Luxor.julia_green, Luxor.julia_red, Luxor.julia_purple, Luxor.julia_blue]\n    sortfaces!(o)\n    if !isempty(o.faces)\n        @layer begin\n            for (n, face) in enumerate(o.faces)\n                @layer begin\n                    vertices = o.vertices[face]\n                    sn = surfacenormal(vertices)\n                    ang = anglebetweenvectors(sn, eyepoint())\n                    sethue(cols[mod1(n, end)])\n                    pin(vertices, gfunction = (p3, p2) ->\n                        begin\n                            poly(p2, :fill)\n                            sethue(\"gold\")\n                            poly(p2, :stroke, close=true)\n                        end)\n                end\n            end\n        end\n    end\n    setcolor(\"gold3\")\n    pin.(o.vertices, gfunction = (p3, p2) -> begin\n        setopacity(1)\n        circle(p2, 2, :fill)\n        end)\nend\n\nobject = make(geodesic, \"geodesic\")\nsetopacity(0.9)\nsetline(0.5)\npin(scaleby!(object, 200, 200, 200), gfunction = mygfunction)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: geodesic)","category":"page"},{"location":"objects/#Faces","page":"Objects","title":"Faces","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"The faces are drawn in the order in which they were defined. But to be a more realistic 3D drawing, the faces should be drawn so that the ones nearest the viewer are drawn last, or better still, so that the ones that can't be seen aren't drawn at all.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"note: Note\nThis is why Thebes is more of a wireframe tool than any kind of genuine 3D application. Use Makie.jl. Or program Blender with Julia.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"In theory it's possible to do some quick calculations on an object to sort the faces into the correct order for a particular viewpoint. The sortfaces!() function used above can do this for simple objects - it may be sufficient.","category":"page"},{"location":"objects/#Using-custom-code","page":"Objects","title":"Using custom code","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"Thebes.jl is a work in progress, and a good general-purpose rendering function that draws everything with lots of optional parameters is not yet provided. However, you can avoid using the built-in pin(o::Object) function, and experiment with code such as the following:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Luxor, Thebes, Colors, ColorSchemes\n\ninclude(dirname(pathof(Thebes)) * \"/../data/moreobjects.jl\")\n\nfunction lighten(col::Colorant, f)\n    c = convert(RGB, col)\n    return RGB(f * c.r, f* c.g, f * c.b)\nend\n\nfunction drawobject(o;\n        color=colorant\"red\")\n    setlinejoin(\"bevel\")\n    if !isempty(o.faces)\n        @layer begin\n            for (n, f) in enumerate(o.faces)\n                vs = o.vertices[f]\n                sn = surfacenormal(vs)\n                ang = anglebetweenvectors(sn, eyepoint())\n                sl = slope(O, vs[1])\n                sethue(lighten(color, rescale(ang, 0, π, -2, 2)))\n                pin(vs, gfunction = (p3, p2) -> begin\n                    poly(p2, :fill)\n                    sethue(\"grey30\")\n                    poly(p2, :stroke)\n                end)\n            end\n        end\n    end\nend\n\nfunction sphere(size, origin, color)\n    s1 = make(sphere2)\n    scaleby!(s1, size, size, size)\n    moveby!(s1, origin)\n    sortfaces!(s1)\n    drawobject(s1, color=color)\nend\n\nfunction main()\n    Drawing(500, 500, \"assets/figures/juliaspheres.svg\")\n    background(\"grey20\")\n    origin()\n    helloworld()\n    eyepoint(300, 300, 300)\n    perspective(450)\n    setline(.5)\n    sphere(90, Point3D(150, 0, 0), RGB(Luxor.julia_red...))\n    sphere(90, Point3D(0, 150, 0), RGB(Luxor.julia_purple...))\n    sphere(90, Point3D(0, 0, 150), RGB(Luxor.julia_green...))\n    finish()\nend\n\nmain()\nnothing # hide","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: custom object)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"text/#Text","page":"Text","title":"Text","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Thebes provides a text3D() function that draws text in a 3D environment. For more information about using fonts and font selection, refer to the chapter in the Luxor documentation.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"You specify the 3D location of the text, and optionally supply rotations and text alignment (halign etc.). By default the text in Thebes (as in Luxor) runs along the x-axis, and it lies in the xy plane.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"Use Rotations.jl to specify rotations.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Thebes, Luxor, Rotations # hide\nDrawing(600, 500, \"assets/figures/text1.svg\") # hide\n\nfontsize(50)\n\nbackground(\"black\")\norigin()\nsetlinejoin(\"bevel\")\neyepoint(Point3D(250, 250, 250))\nperspective(400)\nsethue(\"white\")\naxes3D(220)\n\nfontsize(40)\nfontface(\"Georgia-Italic\")\n\ntext3D(\"the x-axis\", Point3D(0, 0, 0))\ntext3D(\"the y-axis\", Point3D(0, 0, 0), rotation=RotZ(π/2))\ntext3D(\"the z-axis\", Point3D(0, 0, 0), rotation=RotX(-π/2) * RotZ(π/2), halign=:right)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text )","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"You can also use some of Luxor's text functions, such as textextents(), which helps you get the (2D) dimensions of text.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Thebes, Luxor, Colors, Rotations\nDrawing(800, 600, \"assets/figures/text2.svg\") # hide\nbackground(\"black\") # hide\norigin() # hide\neyepoint(Point3D(250, 250, 550))\nperspective(500)\n\nfontsize(50)\n\nte = textextents(\"Julia\")\n\nfor y in -1200:te[3]:1200\n        for x in -1200:te[4]:1200\n            sethue(HSB(mod(x*y, 360), .6, .9))\n            text3D(\"Julia\", Point3D(x, y, 0), about=Point3D(x, y, 0), rotation=RotZ(π/2))\n        end\n    end\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text )","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"text3D","category":"page"},{"location":"text/#Thebes.text3D","page":"Text","title":"Thebes.text3D","text":" text3D(str, anchor::Point3D;\n    halign=:left,\n    valign=:baseline,\n    about=Point3D(0., 0., 0.),\n    rotation::Rotation=RotXYZ(0, 0, 0))\n\nDraw text at point pt, lying in the plane of the x axis. Angles in rotation rotate the text about the about point, defaulting to Point3D(0, 0, 0).\n\nUses Luxor's fontface() and fontsize() settings.\n\nSpecify rotations using functions from Rotations.jl, such as:\n\nRotX(a)\nRotZ(a)\nRotXZ(a1, a2)\nRotXYZ(a1, a2, a3)\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"The basics","title":"The basics","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"basics/#The-basics","page":"The basics","title":"The basics","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Thebes.jl is a small package that adds some simple 3D features to Luxor.jl, a vector-graphics package for graphics workers who like to automate their work with Julia.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"warning: Warning\nRemember: Thebes.jl is intended for simple wireframe constructions in 3D. Don't expect a comprehensive range of 3D modelling and rendering tools. Use Makie.jl (or Blender)!","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The 3D world of Thebes is superimposed on the 2D world of Luxor:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor\n\n@draw begin\n    rulers() # a Luxor function\n    axes3D() # a Thebes function\nend","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: the two worlds)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"There are two main things you have to know in order to draw in 3D:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"the Point3D type specifies the x, y, and z coordinates of a point in 3D space.\nthere's a function called pin() that draws 2D graphics on the Luxor drawing at the position corresponding to the 3D point.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nThe pin() function sort of “pins” a 3D coordinate onto the 2D flat drawing surface. If I think of a better name for this function, I might change it, but I wanted to avoid everything obvious, like “draw”, “render”, “display”, “plot”, and have something short and easy to type.","category":"page"},{"location":"basics/#A-simple-example","page":"The basics","title":"A simple example","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Here's a complete example showing Thebes and Luxor working together:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor\nDrawing(600, 300, \"assets/figures/simpleexample.svg\") # a drawing is required\nbackground(\"white\")      # Luxor\norigin()                 # Luxor\nsetline(1)               # Luxor\naxes3D()                 # Thebes\n\np1 = Point3D(100, 20, 0) # Thebes\n\nloc = pin(p1)            # Thebes  \n\nlabel(\"there it is!\", :e, loc + (5, 0), offset=10, leader=true)  # Luxor\n\nfinish()                 # Luxor\n\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point example)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"tip: Tip\nBecause Thebes.jl displays 3D points on the current 2D Luxor drawing, you should always have a current drawing before using most of the functions from Thebes.","category":"page"},{"location":"basics/#Point-cloud","page":"The basics","title":"Point cloud","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"We can do lots of points - here's half a million or so.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 450, \"assets/figures/pointcloud.png\") #hide\nhelloworld() # hide\norigin() # hide\nbackground(\"black\")\nsetopacity(0.5)\nsethue(\"gold\")\nc = pin.([Point3D(randn() * 50, randn() * 50, randn() * 50)\n    for x in 1:75, y in 1:75, z in 1:75])\naxes3D()\nfinish() # hide\nnothing # hide\nlength(c)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point cloud)","category":"page"},{"location":"basics/#Helical-dots","page":"The basics","title":"Helical dots","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Let's draw a helix made of dots:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix1.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\nhelloworld() # hide\naxes3D()\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point example)","category":"page"},{"location":"basics/#gfunctions","page":"The basics","title":"gfunctions","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"The default graphical rendition of a 3D point is pretty basic: a circle. But you can modify the graphics drawn at each location by passing a function to the pin() function's optional keyword argument, gfunction .","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"Suppose you want to draw a randomly colored circle at the location of each 3D point, with radius 5 units.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix2.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix, gfunction = (_, pt) -> begin\n    randomhue()\n    circle(pt, 5, :fill)\n    end)\n\nfinish()\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point example)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The anonymous function passed to gfunction expects two arguments: the first contains the 3D point, the second contains the 2D point. The function then has the responsibility to draw the 2D graphics for that 2D point, with the possibility of using anything or nothing about the original 3D coordinates. This gives us more control over the rendering of the points.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"If you just want simple Luxor stars, you use the second (2D) argument - you don't need the first (3D) one, and we can use the convention of having _ to signify that.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix2stars.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix, gfunction = (_, pt) -> begin\n    randomhue()\n    star(pt, 5, 5, 0.5, 0.0, :fill)\n    end)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point stars example)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In this next example, the gfunction calculates the distance of the 3D point from the 3D origin, and then draws the 2D circle with a 2D radius that reflects the distance. The function therefore requires both the original 3D point (in the first argument p3) and the second argument (in p2), its 2D projection.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix3.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\naxes3D(100)\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix, gfunction = (p3, p2) -> begin\n    d = rescale(distance(p3, Point3D(0, 0, 0)), 100, 200, 1, 10)\n    circle(p2, d, :fill)\n    end)\n\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point example)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nRemember that all the graphics drawn are 2D graphics. This isn't real 3D, remember! The human brain is quite adaptable, though.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In the next example, each random 3D point is drawn twice, the second time with a zero z coordinate, to make shadows.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n\nDrawing(600, 500,  \"assets/figures/points-shadows.svg\") # hide\norigin() # hide\nbackground(\"grey10\") # hide\neyepoint(Point3D(250, 250, 100)) # hide\nsethue(\"grey50\") # hide\ncarpet(300)\naxes3D(100)\nsethue(\"red\")\nfor i in 1:300\n    randpoint3D = Point3D(rand(0.0:200, 3)...)\n    sethue(\"red\")\n    pin(randpoint3D,\n        gfunction = (_, p2) -> circle(p2, 2, :fill))\n    sethue(\"grey30\")\n    pin(Point3D(randpoint3D.x, randpoint3D.y, 0),\n        gfunction = (_, p2) -> circle(p2, 2, :fill))\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: point example 2)","category":"page"},{"location":"basics/#Lines","page":"The basics","title":"Lines","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Dots are all very well, but suppose we wanted to draw lines? pin() also accepts two 3D points.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"This code uses the same 3D points in the helix, but this time draws a line from each projected 2D point to the projection of the nearest point on the vertical z axis.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix4.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(150cos(θ), 150sin(θ), 5θ) for θ in 0:π/48:4π]\n\nsetline(0.5)\n\nfor p in helix\n    pin(p, Point3D(0, 0, p.z))\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: line example)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The default gfunction's arguments consist of two pairs of points (a pair of 3D points, and a pair of 2D points), not just two of each, and Luxor's trusty line() function is the default action, connecting the 2D pair.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"Or you could provide a custom gfunction to draw multicoloured arrows instead:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/helix5.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(150cos(θ), 150sin(θ), 5θ) for θ in 0:π/48:4π]\n\nsetline(0.5)\n\nfor p in helix\n    pin(p, Point3D(0, 0, p.z), gfunction = (p3p, p2p) ->\n        begin\n            randomhue()\n            arrow(last(p2p), first(p2p))\n        end)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: line example)","category":"page"},{"location":"basics/#When-things-go-wrong","page":"The basics","title":"When things go wrong","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"In 2D graphics, things sometimes go wrong when values get close to zero or infinity. The same thing is true for 3D too, when the coordinates start stressing out the projecting equations. Really good 3D software will prevent this happening. In Thebes, though, you may occasionally see glitches. You're only seeing half the \"world\" that's in front of you  - there's nearly a whole half-world falling behind the eye position, and this means that some points don't get drawn succesfully.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In general, if the pin() function can't display points or lines, it will probably just discard them and carry on, rather than attempt to draw things in impossible locations or straight lines that curve in space. So if you notice parts of your drawing missing, the easiest thing to do is to move the eyepoint further away from the 3D points in question.","category":"page"},{"location":"basics/#Conversions","page":"The basics","title":"Conversions","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"The convert() function provides a useful way to convert 2D coordinates to 3D. If you can generate your graphics in 2D, you can convert them to 3D, and then use pin() to project them back into two dimensions.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"This example shows how to draw the familiar Julia coloured circles. We can't use real circles (because there are no Bézier paths in Thebes yet), so we use ngon() with plenty of sides - 60 is probably good enough if your output is high-quality SVG.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor, Rotations # hide\n\nfunction drawjuliadots3D(threedots, origin::Point3D, rotation::Rotation=RotXYZ(0, 0, 0);\n        radius=100)\n    for (n, dot) in enumerate(threedots)\n        sethue([Luxor.julia_purple, Luxor.julia_green, Luxor.julia_red][mod1(n, end)])\n        d = dot .+ origin\n        rotateby!(d, origin, rotation)\n        pin(d, gfunction = (_, pts) -> poly(pts, close=true, :fill))\n    end\nend\n\nfunction juliaroom()\n    Drawing(500, 500, \"assets/figures/juliaroom.svg\")\n    origin()\n    background(\"black\")\n    helloworld()\n    eyepoint(1200, 1200, 1200)\n    perspective(1200)\n\n    # create the basic three-dot shape\n    threedots = Array{Point3D, 1}[]\n    radius = 8\n    points = ngon(O, radius, 3, -π/3, vertices=true)\n    for (n, p) in enumerate(points)\n        # zcoordinate defaults to 0 in convert()\n        push!(threedots, convert.(Point3D, ngon(p, 0.75 * radius, 60)))\n    end\n\n    # draw lots in each plane\n    for x in 30:30:500\n        for y in 30:30:500\n            drawjuliadots3D(threedots, Point3D(x, y, 0), RotXYZ(0, 0, 0))\n        end\n    end\n\n    for x in 30:30:500\n        for z in 30:30:500\n            drawjuliadots3D(threedots, Point3D(x, 0, z), RotXYZ(-π/2, 0, π/2))\n        end\n    end\n\n    for y in 30:30:500\n        for z in 30:30:500\n            drawjuliadots3D(threedots, Point3D(0, y, z), RotXYZ(0, π/2, 0))\n        end\n    end\n\n    axes3D(300)\n    finish()\nend\n\njuliaroom()\nnothing # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"(Image: the julia room)","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"You could zoom in to see if you can see the straight edges of the circles - I think 60 points is good enough.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"polys/#Polygons-and-planes","page":"Polygons and planes","title":"Polygons and planes","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"The pin() function accepts an array of 3D points as well as singletons and pairs. In this case, the default graphical treatment is to apply the Luxor.poly(... :stroke) function to the array of projected 2D points.","category":"page"},{"location":"polys/#Mobius","page":"Polygons and planes","title":"Möbius","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor # hide\n\nfunction makemobius()\n    x(u, v) = (1 + (v/2 * cos(u/2))) * cos(u)\n    y(u, v) = (1 + (v/2 * cos(u/2))) * sin(u)\n    z(u, v) = v/2 * sin(u/2)\n    w = .5\n    st = 2π/200\n    Δ = .05\n    result = Array{Point3D, 1}[]\n    for u in 0:st:2π-st\n        for v in -w:Δ:w\n            p1 = Point3D(x(u,      v + Δ),   y(u,      v + Δ),     z(u,       v + Δ))\n            p2 = Point3D(x(u + st, v + Δ),   y(u + st, v + Δ),     z(u  + st, v + Δ))\n            p3 = Point3D(x(u + st, v),       y(u + st, v),         z(u + st,  v))\n            p4 = Point3D(x(u,      v),       y(u,      v),         z(u,       v))\n            push!(result, [p1, p2, p3, p4])\n        end\n    end\n    return result # as an array of 3D polygons\nend\n\n# ... in a drawing\nDrawing(600, 600, \"assets/figures/mobiusband.svg\") # hide\norigin() # hide\nbackground(\"black\")\nsetline(0.5) # hide\neyepoint(300, 300, 300)\nperspective(1200)\nmb = makemobius()\nsetopacity(1)\nsethue(\"white\")\nfor pgon in mb\n    pin(100pgon)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"(Image: mobius band)","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"This isn't always going to work perfectly - if the 3D points don't lie in a plane, for example, or if you decide to use fill rather than stroke actions.","category":"page"},{"location":"polys/#Chessboard","page":"Polygons and planes","title":"Chessboard","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"You can probably risk 2D-filling a set of projected 3D points if they lie in the same 3D plane.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"Here's a simple example. The gfunction here:","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"pin(plist,\n    gfunction = (p3, p2) -> begin\n        poly(p2, close=true, :fillpreserve)\n        sethue(\"black\")\n        strokepath()\n    end)","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"fills the polygon with the current colour, then outlines it in black.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor # hide\nDrawing(600, 300, \"assets/figures/chessboard.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nhelloworld() # hide\n\nperspective(1200)\neyepoint(500, 500, 150)\nk = 20\nw, h = 20, 20\nfor x in 1:8\n    for y in 1:8\n        iseven(x + y) ? sethue(\"grey90\") : sethue(\"grey10\")\n        z = 0\n        plist = [\n            Point3D(k * x,     k * y,      z),\n            Point3D(k * x + w, k * y,      z),\n            Point3D(k * x + w, k * y + h,  z),\n            Point3D(k * x,     k * y + h,  z)\n            ]\n        pts = pin(plist, gfunction = (_, p2) -> begin\n                poly(p2, close=true, :fillpreserve)\n                sethue(\"black\")\n                strokepath()\n            end)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"(Image: chess board example)","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"Each square is constructed in a plist and then pin() applies its custom gfunction to it.","category":"page"},{"location":"polys/#Surfaces","page":"Polygons and planes","title":"Surfaces","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"A surface plot like the following also works quite well, mainly because each new polygon hides the ones behind it.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor, Colors # hide\nDrawing(600, 500, \"assets/figures/surfaceplot.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nhelloworld() # hide\n\nperspective(600)\neyepoint(500, 500, 500)\n\nk = 20\nxmax = 4π\nymax = 4π\nst = 0.5\n\nf(x, y) = 2(sin(x) * cos(y)) + (cos(x) * sin(y))\n\nsetline(.5)\n\nfor x in -xmax:st:xmax\n    for y in -ymax:st:ymax\n        sethue(HSB(360rescale(x, -xmax, xmax), .8, .8))\n\n        p1 = Point3D(k * x,         k * y,        k * f(x,      y))\n        p2 = Point3D(k * x,         k * (y + st), k * f(x,      y +st))\n        p3 = Point3D(k * (x + st),  k * (y + st), k * f(x + st, y + st))\n        p4 = Point3D(k * (x + st),  k * y,        k * f(x + st, y))\n        pin([p1, p2, p3, p4], gfunction = (p3s, p2s) -> begin\n            poly(p2s, close=true, :fill)\n            sethue(\"white\")\n            poly(p2s, close=true, :stroke)\n        end)\n    end\nend\n\naxes3D(200)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"(Image: surface plot example)","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"note: Note\nDon't forget to check out Makie.jl for genuine 3D plotting...","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"DocTestSetup = quote\n    using Dates\nend","category":"page"},{"location":"#Introduction-to-Thebes","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"Thebes.jl is a small package that provides a few 3D wireframe tools for use with Luxor.jl, a 2D drawing package. You can define simple shapes in 3D, and have them drawn onto a Luxor drawing.","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"note: Note\nDon't set your expectations too high! Thebes.jl merely generates a few simple 3D \"wireframe\" diagrams. For real 3D work, with solid shapes, lighting, textures, interactivity, and so on, use Makie.jl. Or spend a few months learning Blender...","category":"page"},{"location":"#Installation-and-basic-usage","page":"Introduction to Thebes","title":"Installation and basic usage","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"Install the package using the package manager at the REPL:","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"] add Thebes","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"To use Thebes, type:","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"using Thebes, Luxor","category":"page"},{"location":"#Documentation","page":"Introduction to Thebes","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are some useful tools that might help you explore the limited 3D world provided by Thebes.jl.","category":"page"},{"location":"tools/#Getting-your-hands-dirty","page":"Tools","title":"Getting your hands dirty","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Suppose you want to remove the front-facing faces of an object, in order to see inside. That's possible, but a bit of code is needed.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Thebes, Luxor, Colors # hide\nDrawing(600, 500, \"assets/figures/cullingfaces.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nhelloworld() # hide\neyepoint(200, 200, 200)\naxes3D(300)\nsetlinejoin(\"bevel\")\n\ninclude(dirname(pathof(Thebes)) * \"/../data/moreobjects.jl\")\n\nobjectfull = make(cuboctahedron, \"the full object\")\nobjectcut  = make(cuboctahedron, \"the cut-open object\")\n\nmap(o -> scaleby!(o, 60, 60, 60), (objectfull, objectcut))\n\nfunction cullfrontfaces!(m::Object, angle;\n        eyepoint::Point3D=eyepoint())\n    avgs = Float64[]\n    for f in m.faces\n        vs = m.vertices[f]\n        s = 0.0\n        for v in vs\n            s += distance(v, eyepoint)\n        end\n        avg = s/length(unique(vs))\n\n        θ = surfacenormal(vs)\n        if anglebetweenvectors(θ, eyepoint) > angle\n            push!(avgs, avg)\n        end\n    end\n    neworder = reverse(sortperm(avgs))\n    m.faces = m.faces[neworder]\n    m.labels = m.labels[neworder]\n    return m\nend\n\nsortfaces!.((objectcut, objectfull))\ncullfrontfaces!(objectcut, π/3)\n\ntranslate(-200, 0)\npin(objectcut)\n\ntranslate(400, 0)\npin(objectfull)\n\n@show length(objectcut.faces)\n@show length(objectfull.faces)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The object on the left has had its four frontfacing faces removed. The one on the right is intact.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: culling faces)","category":"page"},{"location":"tools/#Geometry","page":"Tools","title":"Geometry","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are some basic geometry utility functions - some of them are analogous to their Luxor 2D counterparts.","category":"page"},{"location":"tools/#General","page":"Tools","title":"General","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"axes3D\ncarpet\ndrawcube","category":"page"},{"location":"tools/#Thebes.axes3D","page":"Tools","title":"Thebes.axes3D","text":"axes3D(n=100)\n\nDraw labelled 3D axes at (0, 0, 0) with length n.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.carpet","page":"Tools","title":"Thebes.carpet","text":"carpet(n; kind=:circular)\n\nDraw a circular carpet centered at the origin, using current Luxor parameters.\n\nIf kind is not :circular, the carpet will be a square.\n\nPoints that can't be rendered are not included in the final shape.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.drawcube","page":"Tools","title":"Thebes.drawcube","text":"drawcube(n=10, action=:stroke)\n\nDraw a cube. drawcube(1) draws a wireframe unit cube.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Distances","page":"Tools","title":"Distances","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"between\ndistance\nmidpoint","category":"page"},{"location":"tools/#Luxor.between","page":"Tools","title":"Luxor.between","text":"between(p1::Point3D, p2::Point3D, x=0.5)\nbetween((p1::Point3D, p2::Point3D), x=0.5)\n\nFind a point on a line between two 3D points. If x is 0.5, the returned point should be halfway between them.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Luxor.distance","page":"Tools","title":"Luxor.distance","text":"distance(p1::Point3D, p2::Point3D)\n\nReturn the distance between two points.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Luxor.midpoint","page":"Tools","title":"Luxor.midpoint","text":"midpoint(pt1::Point3D, pt2::Point3D)\n\nFind the midpoint between two points. See also between().\n\n\n\n\n\n","category":"function"},{"location":"tools/#Rotations","page":"Tools","title":"Rotations","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The task of rotating points in 3D space is given to Rotations.jl, a powerful and sophisticated package that offers many advanced functions for rotating things in 3D space. For Thebes, you'll probably only need the basics, but there's things like quaternions if you want to get fancy.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"This code draws a cyan square lying in the XY plane with a corner at the 3D origin. The square is then rotated about the Z axis by 180° and drawn in purple. Then the square is rotated again, about the X axis, by 90° and drawn in orange.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes, Rotations # hide\n\nDrawing(500, 500, \"assets/figures/basic-rotations.svg\") # hide\nbackground(\"black\") # hide\norigin() # hide\nsetlinejoin(\"bevel\") # hide\n\neyepoint(Point3D(150, 250, 350))\nperspective(520)\n\nfunction drawsquare(ptlist)\n    pin(ptlist, gfunction = (p3, p2) ->\n        poly(p2, :fill, close=true))\nend\n\nsquare = [Point3D(0, 0, 0), Point3D(100, 0, 0), Point3D(100, 100, 0), Point3D(0, 100, 0)]\n\nsethue(\"cyan\")\ndrawsquare(square)\n\nsethue(\"purple\")\nrotateby!(square, RotZ(π))\ndrawsquare(square)\n\nsethue(\"orange\")\nrotateby!(square, RotX(-π/2))\ndrawsquare(square)\n\naxes3D(160)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: basic rotations)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The most useful rotation functions are RotX(), RotY(), RotZ(), RotXY(), and RotXYZ(), which rotate around the axes. All the other permutations are available. A RotXYZ() rotation takes three angles. The right-most rotation is applied first, so RotXYZ() applies the Z rotation, followed by the Y, then followed by the X.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"You can compose two or more rotations by multiplying them together, eg RotX(π/2) * RotZ(π/4).","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The rotation functions without ! return new points or arrays of points.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are also functions that accept a second 3D point, the about point. The rotation  is applied around that point, rather than an axis. In the next example, the square is rotated in Z about the corner point at Point3D(100, 100, 0) and drawn in green.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes, Rotations # hide\n\nDrawing(600, 600, \"assets/figures/basic-rotations-about.svg\") # hide\nbackground(\"black\") # hide\norigin() # hide\nsetlinejoin(\"bevel\") # hide\n\neyepoint(Point3D(350, 350, 350)) # hide\nperspective(320) # hide\n\nfunction drawsquare(ptlist) # hide\n    pin(ptlist, gfunction = (p3, p2) -> # hide\n        poly(p2, :fill, close=true)) # hide\nend # hide\n\nsquare = [Point3D(0, 0, 0), Point3D(100, 0, 0), Point3D(100, 100, 0), Point3D(0, 100, 0)] # hide\n\nsethue(\"grey40\")\ndrawsquare(square)\n\nsethue(\"green\")\nrotateby!(square, Point3D(100, 100, 0), RotZ(π))\ndrawsquare(square)\n\naxes3D(160)\nfinish() # hide\nnothing #hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: basic rotations about)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateby(point::Point3D, r::Rotation)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(m::Object, angleX, angleY, angleZ)\nrotateby(m::Object, pt::Point3D, angleX, angleY, angleZ)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Those with ! mutate the array of points in place. (You can't modify a single point.)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateby!(ptlist::Vector{Point3D}, r::RotXYZ{Float64})\nrotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(m::Object, angleX, angleY, angleZ)\nrotateby!(m::Object, pt::Point3D, angleX, angleY, angleZ)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateX\nrotateY\nrotateZ\nrotateby!\nrotateby","category":"page"},{"location":"tools/#Thebes.rotateX","page":"Tools","title":"Thebes.rotateX","text":"rotateX(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the x axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateY","page":"Tools","title":"Thebes.rotateY","text":"rotateY(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the y axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateZ","page":"Tools","title":"Thebes.rotateZ","text":"rotateZ(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the z axis by an angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateby!","page":"Tools","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\n\nModify a list of points by rotating each one around the x, y, and z axes by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(ptlist::Array{Point3D, 1}, r::Rotation=RotXYZ{Float64})\n\nRotate each point in the list by rotation (or angleX, angleY, angleZ) around another point (or origin).\n\n\n\n\n\nrotateby!(o::Object, r::Rotation)\nrotateby!(o::Object, angleX, angleY, angleZ)\n\nRotate an object through rotation r, or around the x, y, and/or z axis by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby!(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby!(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate an object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateby","page":"Tools","title":"Thebes.rotateby","text":"rotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(point::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\n\nReturn a new point/list of points resulting from rotating around the x, y, and z axes by angleX, angleY, angleZ.\n\nThe Z rotation is first, then the Y, then the X.\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XYZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\nrotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\n\n\n\n\n\nrotateby(o::Object, angleX, angleY, angleZ)\n\nRotate a copy of the object by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate a copy of the object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Position-and-scale","page":"Tools","title":"Position and scale","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"You can change the position and scale of things. moveby() makes a copy, moveby!() moves the original.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In the next example, the square is first moved by -100/-100/0, then copies are moved upwards by the loop index i.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes # hide\n\nDrawing(600, 600, \"assets/figures/basic-moves.svg\") # hide\nbackground(\"black\") # hide\norigin() # hide\nsetlinejoin(\"bevel\") # hide\n\neyepoint(Point3D(350, 350, 350)) # hide\nperspective(320) # hide\n\nfunction drawsquare(ptlist) # hide\n    pin(ptlist, gfunction = (p3, p2) -> # hide\n        poly(p2, :fill, close=true)) # hide\nend # hide\n\nsquare = [Point3D(0, 0, 0), Point3D(100, 0, 0), Point3D(100, 100, 0), Point3D(0, 100, 0)] # hide\n\nsethue(\"grey40\")\ndrawsquare(square)\n\nmoveby!(square, Point3D(-100, -100, 0))\n\nsetopacity(.6)\nfor i in 10:10:200\n    randomhue()\n    drawsquare(moveby.(square, Point3D(0, 0, i)))\nend\n\naxes3D(160)\n\nfinish() # hide\nnothing #hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: basic moves)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"scaleby!() changes the scale of a list of points.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes # hide\n\nDrawing(600, 600, \"assets/figures/basic-scale.svg\") # hide\nbackground(\"black\") # hide\norigin() # hide\nsetlinejoin(\"bevel\") # hide\n\nhelloworld() # hide\n\nfunction drawsquare(ptlist) # hide\n    pin(ptlist, gfunction = (p3, p2) -> # hide\n        poly(p2, :fill, close=true)) # hide\nend # hide\n\naxes3D(160)\n\nsquare = [Point3D(0, 0, 0), Point3D(100, 0, 0), Point3D(100, 100, 0), Point3D(0, 100, 0)] # hide\n\nsethue(\"red\")\ndrawsquare(square)\n\nsethue(\"blue\")\nscaleby!(square, .5, 2, 1)\nmoveby!(square, Point3D(0, 0, 30))\ndrawsquare(square)\n\nfinish() # hide\nnothing #hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: basic scale)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"moveby!\nmoveby\nscaleby!","category":"page"},{"location":"tools/#Thebes.moveby!","page":"Tools","title":"Thebes.moveby!","text":"moveby!(ptlist::Point3D, x, y, z)\nmoveby!(ptlist::Point3D, pt::Point3D)\n\nMove all points in the list by a vector.\n\n\n\n\n\nmoveby!(o::Object, x, y, z)\nmoveby!(o::Object, pt::Point3D)\n\nSet the position of object to Point3D(x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.moveby","page":"Tools","title":"Thebes.moveby","text":"moveby(pt::Point3D, d::Point3D)\n\nReturn a new point that's the result of moving a point pt by a vector d.\n\n\n\n\n\nmoveby(o::Object, x, y, z)\nmoveby(o::Object, pt::Point3D)\n\nSet the position of a copy of the object to Point3D(x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.scaleby!","page":"Tools","title":"Thebes.scaleby!","text":"scaleby!(ptlist::Array{Point3D, 1}, x, y, z)\n\nScales a list of points by multiplying by x in X, y in Y, z in Z.\n\n\n\n\n\nscaleby!(o::Object, x, y, z)\n\nScale object by x in x, y in y, and z in z.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Coordinates","page":"Tools","title":"Coordinates","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"sphericaltocartesian\ncartesiantospherical\n\ndotproduct3D\ncrossproduct3D\nmagnitude\nanglebetweenvectors\nsurfacenormal\npointsperpendicular","category":"page"},{"location":"tools/#Thebes.sphericaltocartesian","page":"Tools","title":"Thebes.sphericaltocartesian","text":"sphericaltocartesian(ρ, θ, ϕ)\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ):\n\nρ is the distance from the origin (ie radius)\nθ is the azimuthal angle (the longitude) 0 is +x, π is -x, 2π is +x\nϕ is the polar angle (the latitude) 0 is North Pole, π is South Pole\n\nThere are two major conventions for spherical coordinate notation.\n\nIn physics books:\n\n(ρ, θ, φ) gives the radial distance, polar angle (latitude), and azimuthal angle (longitude)\n\nIn mathematics books:\n\n(ρ, θ , φ ) gives the radial distance, azimuthal angle (longitude), and polar angle (latitude)\n\nSo we're using the mathematics one here.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.cartesiantospherical","page":"Tools","title":"Thebes.cartesiantospherical","text":"cartesiantospherical(x, y, z)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of the Point3D(x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.dotproduct3D","page":"Tools","title":"Thebes.dotproduct3D","text":"dotproduct3D(a::Point3D, b::Point3D)\n\nFinds the dot product of a and b\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.crossproduct3D","page":"Tools","title":"Thebes.crossproduct3D","text":"crossproduct3D(A::Point3D, B::Point3D)\n\nFind one of these.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.magnitude","page":"Tools","title":"Thebes.magnitude","text":"magnitude(a::Point3D)\n\nCalculates magnitude of a.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.anglebetweenvectors","page":"Tools","title":"Thebes.anglebetweenvectors","text":"anglebetweenvectors(v1::Point3D, v2::Point3D)\n\nCalclate the angle between two vectors.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.surfacenormal","page":"Tools","title":"Thebes.surfacenormal","text":"surfacenormal(ptlist::Array{Point3D, 1})\n\nFinds one of these.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.pointsperpendicular","page":"Tools","title":"Thebes.pointsperpendicular","text":"pointsperpendicular(p1::Point3D, p2::Point3D, radius, angles = [0, π])\n\nFind points perpendicular to a line joining p1 and p2. Points are radius units away from the line.\n\n\n\n\n\n","category":"function"},{"location":"views/","page":"Views","title":"Views","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"views/#Views-and-perspective","page":"Views","title":"Views and perspective","text":"","category":"section"},{"location":"views/#Eyepoint-and-centerpoint","page":"Views","title":"Eyepoint and centerpoint","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Thebes takes a simple view of life. There’s a global Thebes ‘realm’ which is created when you start using it. It’s a good idea to check and/or set the current viewing parameters when you start a new Luxor document, in case you’re inheriting anything from a previous run.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"Here are the functions that control your view of the 3D scene:","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"helloworld()  \neyepoint()  \ncenterpoint()\nuppoint()\nperspective()","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"The first one is a useful one to remember: it simply resets all the viewing parameters to the default settings.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"The eyepoint() function moves the eyepoint, and centerpoint() changes the location that is the center of your view. The uppoint() function specifies a point relative to centerpoint. A line running from centerpoint to the up point defines the “up” direction.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"So, to see the side view of the helix, continued from the previous chapter, we can just lower our viewpoint a bit, from the default 100 in z down to 50:","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\nDrawing(600, 200, \"assets/figures/helix6.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nuppoint(0, 0, 100) # hide\ncenterpoint(0, 0, 50) # hide\n\nhelix = [Point3D(150cos(θ), 150sin(θ), 5θ) for θ in 0:π/48:4π]\n\nsetline(0.2)\n\neyepoint(500, 500, 50)\n\naxes3D()\n\nfor p in helix\n    pin(p, Point3D(0, 0, p.z))\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: point example)","category":"page"},{"location":"views/#Perspective","page":"Views","title":"Perspective","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"As yet we've seen no perspective. The defaut value of the perspective parameter, as returned by perspective(), is 0. This means that there's none of that foreshortening or converging of lines that head off into the distance. And if you look at a cube, it has that familiar unrealistic appearance of cubes drawn without perspective.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\n\nhelloworld() # hide\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\nDrawing(600, 300, \"assets/figures/cube1.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\n\npin(50makecube())\n\nfinish()\nnothing # hide","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: isometric cube example)","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"This animation views the cube and changes the perspective slowly, starting at 0, then moving from 300 up to 1400.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: perspective cube example)","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"As the value of perspective increases, the apparent magnification increases, and parallel lines start to converge. The next example shows the converging parallel lines.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\n\nhelloworld() # hide\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\nDrawing(600, 300, \"assets/figures/cube-in-perspective.svg\") #hide\nbackground(\"white\") # hide\norigin() # hide\n\neyepoint(200, 50, 100)\nperspective(150)\npts = pin(50makecube())\n\nsethue(\"red\")\nsetline(0.1)\nfor p1 in pts\n    for p2 in pts\n        p1 == p2 && continue\n        rule(p1, slope(p1, p2))\n    end\nend\n\nfinish() # hide\nnothing # hide\n","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: cube in perspective)","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"There are enough converging parallel lines there to give an ancient Egyptian architect nightmares.","category":"page"},{"location":"views/#Orbits","page":"Views","title":"Orbits","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"To fly around the scene, move the eyepoint around, while looking at the center.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor\nfunction frame(scene, framenumber, object)\n    background(\"skyblue\")\n    setlinejoin(\"bevel\")\n\n    setline(3.0)\n    sethue(\"grey30\")\n    carpet(500)\n    eased_n = rescale(scene.easingfunction(framenumber, 0, 1,\n        scene.framerange.stop), 0, 1, 0, 2π)\n\n    sethue(\"white\")\n    perspective(200)\n    eyepoint(200cos(eased_n), 200sin(eased_n), 40)\n    pts = pin(50object)\n\n    sethue(\"orange\")\n    setline(0.5)\n    for pair in ((1, 2), (2, 3), (3, 4), (4, 1))\n        rule(pts[first(pair)], slope(pts[first(pair)], pts[last(pair)]))\n    end\n\n    axes3D()\nend\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\n\nfunction main()\n    w = 600\n    h = 400\n    movie1 = Movie(w, h, \"3D movie\")\n    cube = makecube()\n    d = animate(movie1,\n            Scene(movie1, (s, f)  -> frame(s, f, cube),\n                    1:150, easingfunction=easeinoutsine),\n        creategif=true,\n        framerate=20,\n        pathname=\"/tmp/orbiting-a-cube.gif\")\n    return d\nend\n\nmain()","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: animation)","category":"page"}]
}
