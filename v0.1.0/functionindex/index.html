<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · Thebes</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Thebes logo"/></a><div class="docs-package-name"><span class="docs-autofit">Thebes</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to Thebes</a></li><li><a class="tocitem" href="../basics/">The basics</a></li><li><a class="tocitem" href="../views/">Views</a></li><li><a class="tocitem" href="../polys/">Polygons and planes</a></li><li><a class="tocitem" href="../objects/">Objects</a></li><li><a class="tocitem" href="../text/">Text</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li class="is-active"><a class="tocitem" href>Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cormullion/Thebes.jl/blob/master/docs/src/functionindex.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#Luxor.between"><code>Luxor.between</code></a></li><li><a href="../tools/#Luxor.between"><code>Luxor.between</code></a></li><li><a href="#Luxor.distance-Tuple{Point3D,Point3D}"><code>Luxor.distance</code></a></li><li><a href="../tools/#Luxor.distance"><code>Luxor.distance</code></a></li><li><a href="#Luxor.midpoint-Tuple{Point3D,Point3D}"><code>Luxor.midpoint</code></a></li><li><a href="../tools/#Luxor.midpoint"><code>Luxor.midpoint</code></a></li><li><a href="../tools/#Thebes.anglebetweenvectors"><code>Thebes.anglebetweenvectors</code></a></li><li><a href="#Thebes.anglebetweenvectors-Tuple{Point3D,Point3D}"><code>Thebes.anglebetweenvectors</code></a></li><li><a href="../tools/#Thebes.axes3D"><code>Thebes.axes3D</code></a></li><li><a href="#Thebes.axes3D"><code>Thebes.axes3D</code></a></li><li><a href="#Thebes.carpet"><code>Thebes.carpet</code></a></li><li><a href="../tools/#Thebes.carpet"><code>Thebes.carpet</code></a></li><li><a href="../tools/#Thebes.cartesiantospherical"><code>Thebes.cartesiantospherical</code></a></li><li><a href="#Thebes.cartesiantospherical-Tuple{Any,Any,Any}"><code>Thebes.cartesiantospherical</code></a></li><li><a href="#Thebes.dotproduct3D-Tuple{Point3D,Point3D}"><code>Thebes.dotproduct3D</code></a></li><li><a href="../tools/#Thebes.dotproduct3D"><code>Thebes.dotproduct3D</code></a></li><li><a href="#Thebes.drawcube"><code>Thebes.drawcube</code></a></li><li><a href="../tools/#Thebes.drawcube"><code>Thebes.drawcube</code></a></li><li><a href="#Thebes.face-Tuple{Object,Any}"><code>Thebes.face</code></a></li><li><a href="#Thebes.helloworld-Tuple{}"><code>Thebes.helloworld</code></a></li><li><a href="../tools/#Thebes.magnitude"><code>Thebes.magnitude</code></a></li><li><a href="#Thebes.magnitude-Tuple{Point3D}"><code>Thebes.magnitude</code></a></li><li><a href="#Thebes.make"><code>Thebes.make</code></a></li><li><a href="#Thebes.newprojection"><code>Thebes.newprojection</code></a></li><li><a href="#Thebes.objecttopoly-Tuple{Object}"><code>Thebes.objecttopoly</code></a></li><li><a href="#Thebes.pin-Tuple{Point3D}"><code>Thebes.pin</code></a></li><li><a href="#Thebes.pin-Tuple{Array{Point3D,1}}"><code>Thebes.pin</code></a></li><li><a href="#Thebes.pin-Tuple{Point3D,Point3D}"><code>Thebes.pin</code></a></li><li><a href="#Thebes.pin-Tuple{Object}"><code>Thebes.pin</code></a></li><li><a href="#Thebes.project-Tuple{Point3D}"><code>Thebes.project</code></a></li><li><a href="#Thebes.rotateX-Tuple{Point3D,Any}"><code>Thebes.rotateX</code></a></li><li><a href="../tools/#Thebes.rotateX"><code>Thebes.rotateX</code></a></li><li><a href="../tools/#Thebes.rotateY"><code>Thebes.rotateY</code></a></li><li><a href="#Thebes.rotateY-Tuple{Point3D,Any}"><code>Thebes.rotateY</code></a></li><li><a href="../tools/#Thebes.rotateZ"><code>Thebes.rotateZ</code></a></li><li><a href="#Thebes.rotateZ-Tuple{Point3D,Any}"><code>Thebes.rotateZ</code></a></li><li><a href="#Thebes.rotateby-Tuple{Object,Any,Any,Any}"><code>Thebes.rotateby</code></a></li><li><a href="#Thebes.rotateby-Tuple{Object,Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a></li><li><a href="../tools/#Thebes.rotateby"><code>Thebes.rotateby</code></a></li><li><a href="#Thebes.rotateby-Tuple{Point3D,Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a></li><li><a href="#Thebes.rotateby-Tuple{Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a></li><li><a href="#Thebes.rotateby!-Tuple{Object,Any,Any,Any}"><code>Thebes.rotateby!</code></a></li><li><a href="../tools/#Thebes.rotateby!"><code>Thebes.rotateby!</code></a></li><li><a href="#Thebes.rotateby!-Tuple{Object,Point3D,Any,Any,Any}"><code>Thebes.rotateby!</code></a></li><li><a href="#Thebes.setposition-Tuple{Object,Any,Any,Any}"><code>Thebes.setposition</code></a></li><li><a href="../tools/#Thebes.setposition"><code>Thebes.setposition</code></a></li><li><a href="#Thebes.setposition!-Tuple{Object,Any,Any,Any}"><code>Thebes.setposition!</code></a></li><li><a href="../tools/#Thebes.setposition!"><code>Thebes.setposition!</code></a></li><li><a href="#Thebes.setposition!-Tuple{Array{Point3D,1},Point3D}"><code>Thebes.setposition!</code></a></li><li><a href="../tools/#Thebes.setscale!"><code>Thebes.setscale!</code></a></li><li><a href="#Thebes.setscale!-Tuple{Object,Any,Any,Any}"><code>Thebes.setscale!</code></a></li><li><a href="#Thebes.simplegfunction-Tuple{Any,Any,Any}"><code>Thebes.simplegfunction</code></a></li><li><a href="#Thebes.sortfaces!-Tuple{Object}"><code>Thebes.sortfaces!</code></a></li><li><a href="../tools/#Thebes.sphericaltocartesian"><code>Thebes.sphericaltocartesian</code></a></li><li><a href="#Thebes.sphericaltocartesian-Tuple{Any,Any,Any}"><code>Thebes.sphericaltocartesian</code></a></li><li><a href="#Thebes.surfacenormal-Tuple{Any}"><code>Thebes.surfacenormal</code></a></li><li><a href="../tools/#Thebes.surfacenormal"><code>Thebes.surfacenormal</code></a></li><li><a href="#Thebes.text3D-Tuple{Any,Point3D}"><code>Thebes.text3D</code></a></li><li><a href="../text/#Thebes.text3D"><code>Thebes.text3D</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">between(p1::Point3D, p2::Point3D, x=0.5)
between((p1::Point3D, p2::Point3D), x=0.5)</code></pre><p>Find a point on a line between two 3D points. If <code>x</code> is 0.5, the returned point should be halfway between them.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.distance-Tuple{Point3D,Point3D}" href="#Luxor.distance-Tuple{Point3D,Point3D}"><code>Luxor.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(p1::Point3D, p2::Point3D)</code></pre><p>Return the distance between two points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{Point3D,Point3D}" href="#Luxor.midpoint-Tuple{Point3D,Point3D}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">midpoint(pt1::Point3D, pt2::Point3D)</code></pre><p>Find the midpoint between two points. See also <code>between()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.anglebetweenvectors-Tuple{Point3D,Point3D}" href="#Thebes.anglebetweenvectors-Tuple{Point3D,Point3D}"><code>Thebes.anglebetweenvectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">anglebetweenvectors(v1::Point3D, v2::Point3D)</code></pre><p>Calclates anglebetweenvectors</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.axes3D" href="#Thebes.axes3D"><code>Thebes.axes3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">axes3D(n=100)</code></pre><p>Draw labelled 3D axes at <code>(0, 0, 0)</code> with length <code>n</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.carpet" href="#Thebes.carpet"><code>Thebes.carpet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carpet(n; kind=:circular)</code></pre><p>Draw a circular carpet centered at the origin, using current Luxor parameters.</p><p>If <code>kind</code> is not <code>:circular</code>, the carpet will be a square.</p><p>Points that can&#39;t be rendered are not included in the final shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.cartesiantospherical-Tuple{Any,Any,Any}" href="#Thebes.cartesiantospherical-Tuple{Any,Any,Any}"><code>Thebes.cartesiantospherical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesiantospherical(x, y, z)</code></pre><p>Return (phi, rho, theta) of (x, y, z).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.dotproduct3D-Tuple{Point3D,Point3D}" href="#Thebes.dotproduct3D-Tuple{Point3D,Point3D}"><code>Thebes.dotproduct3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dotproduct3D(a::Point3D, b::Point3D)</code></pre><p>Finds the dot product of a and b</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.drawcube" href="#Thebes.drawcube"><code>Thebes.drawcube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawcube(n=10, action=:stroke)</code></pre><p>Draw a cube.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.face-Tuple{Object,Any}" href="#Thebes.face-Tuple{Object,Any}"><code>Thebes.face</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">face(m::Object, n)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.helloworld-Tuple{}" href="#Thebes.helloworld-Tuple{}"><code>Thebes.helloworld</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">helloworld()</code></pre><p>Reset all the things. The equivalent of typing:</p><pre><code class="language-none">eyepoint(100, 100, 100)
centerpoint(0, 0, 0)
uppoint(0, 0, 10)
perspective(0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.magnitude-Tuple{Point3D}" href="#Thebes.magnitude-Tuple{Point3D}"><code>Thebes.magnitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">magnitude(a::Point3D)</code></pre><p>Calculates magnitude of a.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.make" href="#Thebes.make"><code>Thebes.make</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make(primitive, name=&quot;unnamed&quot;)</code></pre><p><code>primitive</code> contains two arrays, an array of 3D points, and an array of faces, where each face is a list of vertex numbers.</p><p>Returns a Object.</p><p>Example</p><pre><code class="language-none">make(Cube, &quot;cube&quot;)</code></pre><p>returns an Object object containing an array of vertices, an array of faces, and an array of labels.</p><pre><code class="language-none">@draw begin
    helloworld()
    tol = 0.01
    a = []
    sethue(&quot;black&quot;)
    for t in -2pi:tol:2pi
        push!(a, Point3D((50 + cos(5t)) * cos(3t), (50 + cos(5t)) * sin(2t), sin(5t)))
    end
    Knot = make((a, []), &quot;knot&quot;)
    pin(Knot, gfunction = (args...) -&gt; poly(args[1], :stroke))
end

The default gfunction expects faces - if there aren&#39;t any, use a gfunction that draws vertices.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.newprojection" href="#Thebes.newprojection"><code>Thebes.newprojection</code></a> — <span class="docstring-category">Function</span></header><section><div><p>newprojection(ipos::Point3D, center::Point3D, up::Point3D, perspective=0.0)</p><p>Define a new Projection:</p><ul><li>ipos is the eye position</li><li>center is the 3D point to appear in the center of the 2D image</li><li>up is a point that is to appear vertically above the center</li></ul><p>If <code>perspective</code> is 0.0 (the default) the projection is parallel. Otherwise it&#39;s a vague magnification factor for perspective projections.</p><p>The three vectors U, V, W, and the three scalar products, ue, ve, and we:</p><ul><li>u is at right angles to line of sight w, and to t-e, so it corresponds to</li></ul><p>the x axis of the 2D image</p><ul><li>v is at right angles to u and to the line of sight, so it&#39;s the y axis of the</li></ul><p>2D image</p><ul><li><p>w is the line of sight</p></li><li><p>we is the projection of the eye position onto w</p></li><li><p>ue is the projection of the eye position onto that x-axis</p></li><li><p>ve is the projection of the eye position onto that y axis</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.objecttopoly-Tuple{Object}" href="#Thebes.objecttopoly-Tuple{Object}"><code>Thebes.objecttopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objecttopoly(m::Object)</code></pre><p>Return a list of 2D points representing the 3D Object in <code>m</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.pin-Tuple{Array{Point3D,1}}" href="#Thebes.pin-Tuple{Array{Point3D,1}}"><code>Thebes.pin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pin(p3list::Array{Point3D, 1};
    gfunction = (p3list, p2list) -&gt;
        poly(p2list, :stroke, close=true))</code></pre><p>Draw an array of 3D points.</p><p>The default action is to draw a polygon through all the points.</p><p>The gfunction can access the 3D points as the first argument, the two 2D points in the second argument.</p><pre><code class="language-none">helix = [Point3D(100cos(θ), 100sin(θ), 20θ) for θ in 0:π/12:4π]
a_box = pin(helix, gfunction =
    (p3list, p2list) -&gt; prettypoly(p2list, :stroke)
    )</code></pre><p>Returns the list of 2D points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.pin-Tuple{Object}" href="#Thebes.pin-Tuple{Object}"><code>Thebes.pin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pin(m::Object;
    gfunction = (v, f, l; kwargs... ) -&gt; simplegfunction(v, f, l; kwargs...))</code></pre><p>Draw an object, calling a gfunction, the default is <code>simplegfunction()</code>.</p><p>To define and change the default gfunction:</p><pre><code class="language-none">function mygfunction(vertices, faces, labels; action=:fill)
    setlinejoin(&quot;bevel&quot;)
    if !isempty(faces)
        @layer begin
            for (n, p) in enumerate(faces)
                 @layer begin
                     isodd(n) ? sethue(&quot;grey30&quot;) : sethue(&quot;grey90&quot;)
                     setopacity(0.5)
                     poly(p, action)
                 end
                 sethue(&quot;black&quot;)
                 setline(0.5)
                 poly(p, :stroke, close=true)
             end
        end
    end
end

@svg begin
    helloworld()
    object = make(Cube)
    setscale!(object, 100, 100, 100)
    rotateby!(object, object.vertices[1], rand(), rand(), rand())
    sortfaces!(object)
    pin(object, gfunction = mygfunction)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.pin-Tuple{Point3D,Point3D}" href="#Thebes.pin-Tuple{Point3D,Point3D}"><code>Thebes.pin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pin(p3_1::Point3D, p3_2::Point3D;
    gfunction = ((p3_1, p3_2), (p2_1, p2_2)) -&gt;
        line(p2_1, p2_2, :stroke))</code></pre><p>Draw two 3D points.</p><p>The default action is to draw a line between two points.</p><p>The gfunction can access the 3D points as the first argument, the two 2D points in the second argument.</p><pre><code class="language-none">pin(p, Point3D(50cos(θ), 50sin(θ), p.z),
    gfunction = (p3s, p2s) -&gt; begin
        line(p2s..., :stroke)
    end)
</code></pre><p>Returns the two 2D points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.pin-Tuple{Point3D}" href="#Thebes.pin-Tuple{Point3D}"><code>Thebes.pin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pin(pt::Point3D;
    gfunction = (p3, p2) -&gt; circle(p2, 1, :stroke))</code></pre><p>Draw a single 3D point on the current Luxor drawing.</p><p>The default graphic is a circle. You can define others using a custom gfunction, which takes two arguments: the 3D point and its 2D counterpoint.</p><p>For example, this draws a circle whose radius is larger if the point is nearer to the eye.</p><pre><code class="language-none">pin(p, gfunction = (p3, p2) -&gt; begin
        d = distance(p3, eyepoint())
        circle(p2, rescale(d, 0, 300, 20, 5), :fill)
    end
    )</code></pre><p>Returns the 2D point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.project-Tuple{Point3D}" href="#Thebes.project-Tuple{Point3D}"><code>Thebes.project</code></a> — <span class="docstring-category">Method</span></header><section><div><p>project(P::Point3D)</p><p>Project a 3D point onto a 2D surface, as defined by the current projection.</p><p>TODO Currently this returns &#39;nothing&#39; if the point is behind the eyepoint. This makes handling the conversion a bit harder, though, since the function now returns either a 2D Luxor point or <code>nothing</code>.</p><pre><code class="language-none">using Thebes, Luxor

@svg begin
    eyepoint(Point3D(250, 250, 100))
    centerpoint(Point3D(0, 0, 0))
    uppoint(Point3D(0, 0, 1))
    sethue(&quot;grey50&quot;)
    carpet(300)
    axes3D(100)
    sethue(&quot;red&quot;)
    for i in 1:30
        randpoint3D = Point3D(rand(0.0:150, 3)...)
        sethue(&quot;red&quot;)
        pt1 = pin(randpoint3D)
        if pt1 != nothing
            circle(pt1, 5, :fill)
        end
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateX-Tuple{Point3D,Any}" href="#Thebes.rotateX-Tuple{Point3D,Any}"><code>Thebes.rotateX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateX(pt3D::Point3D, rad)</code></pre><p>Return a new point resulting from rotating the point around the x axis by an angle in radians.</p><p>Rotations are anticlockwise when looking along axis from 0 to +axis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateY-Tuple{Point3D,Any}" href="#Thebes.rotateY-Tuple{Point3D,Any}"><code>Thebes.rotateY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateY(pt3D::Point3D, rad)</code></pre><p>Return a new point resulting from rotating the point around the y axis by an angle in radians.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateZ-Tuple{Point3D,Any}" href="#Thebes.rotateZ-Tuple{Point3D,Any}"><code>Thebes.rotateZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateZ(pt3D::Point3D, rad)</code></pre><p>Return a new point resulting from rotating the point around the z axis by an angle in radians.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby!-Tuple{Object,Any,Any,Any}" href="#Thebes.rotateby!-Tuple{Object,Any,Any,Any}"><code>Thebes.rotateby!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby!(m::Object, angleX, angleY, angleZ)</code></pre><p>Rotate an object around the x, y, and/or z axis by angleX, angleY, angleZ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby!-Tuple{Object,Point3D,Any,Any,Any}" href="#Thebes.rotateby!-Tuple{Object,Point3D,Any,Any,Any}"><code>Thebes.rotateby!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby!(m::Object, pt::Point3D, angleX, angleY, angleZ)</code></pre><p>Rotate an object around a point by angleX, angleY, angleZ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby-Tuple{Object,Any,Any,Any}" href="#Thebes.rotateby-Tuple{Object,Any,Any,Any}"><code>Thebes.rotateby</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby(m::Object, angleX, angleY, angleZ)</code></pre><p>Rotate a copy of the object by angleX, angleY, angleZ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby-Tuple{Object,Point3D,Any,Any,Any}" href="#Thebes.rotateby-Tuple{Object,Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby(m::Object, pt::Point3D, angleX, angleY, angleZ)</code></pre><p>Rotate a copy of the object around a point by angleX, angleY, angleZ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby-Tuple{Point3D,Any,Any,Any}" href="#Thebes.rotateby-Tuple{Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby(pt::Point3D, angleX, angleY, angleZ)</code></pre><p>Return a new point resulting from rotating the specified point around the x, y, and z axes by angleX, angleY, angleZ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.rotateby-Tuple{Point3D,Point3D,Any,Any,Any}" href="#Thebes.rotateby-Tuple{Point3D,Point3D,Any,Any,Any}"><code>Thebes.rotateby</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotateby(newpt::Point3D, existingpt::Point3D, angleX, angleY, angleZ)</code></pre><p>Return a new point resulting from rotating the point by angleX, angleY, angleZ around another point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.setposition!-Tuple{Array{Point3D,1},Point3D}" href="#Thebes.setposition!-Tuple{Array{Point3D,1},Point3D}"><code>Thebes.setposition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setposition!(ptlist::Point3D, pt::Point3D)</code></pre><p>Move points by a vector..</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.setposition!-Tuple{Object,Any,Any,Any}" href="#Thebes.setposition!-Tuple{Object,Any,Any,Any}"><code>Thebes.setposition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setposition!(m::Object, x, y, z)
setposition!(m::Object, pt::Point3D)</code></pre><p>Set the position of object to Point3D(x, y, z).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.setposition-Tuple{Object,Any,Any,Any}" href="#Thebes.setposition-Tuple{Object,Any,Any,Any}"><code>Thebes.setposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setposition(m::Object, x, y, z)
setposition(m::Object, pt::Point3D)</code></pre><p>Set the position of a copy of the object to Point3D(x, y, z).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.setscale!-Tuple{Object,Any,Any,Any}" href="#Thebes.setscale!-Tuple{Object,Any,Any,Any}"><code>Thebes.setscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>setscale!(m::Object, x, y, z)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.simplegfunction-Tuple{Any,Any,Any}" href="#Thebes.simplegfunction-Tuple{Any,Any,Any}"><code>Thebes.simplegfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simplegfunction(vertices, faces, labels; action=:stroke)</code></pre><p>In a Luxor drawing, draw the 2D vertices and faces, using alternating grey shades.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.sortfaces!-Tuple{Object}" href="#Thebes.sortfaces!-Tuple{Object}"><code>Thebes.sortfaces!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sortfaces!(m::Object;
    eyepoint::Point3D=Point3D(0, 0, 0))</code></pre><p>Find the averages of the z values of the faces in Object, and sort the faces of m so that the faces are in order of nearest (highest) z relative to eyepoint...</p><p>or something like that ? not sure how this works</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.sphericaltocartesian-Tuple{Any,Any,Any}" href="#Thebes.sphericaltocartesian-Tuple{Any,Any,Any}"><code>Thebes.sphericaltocartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphericaltocartesian(rho, theta, phi)</code></pre><p>Return Point3D(x, y, z) of (rho, theta, phi).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.surfacenormal-Tuple{Any}" href="#Thebes.surfacenormal-Tuple{Any}"><code>Thebes.surfacenormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfacenormal(ptlist)</code></pre><p>Finds one of these.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Thebes.text3D-Tuple{Any,Point3D}" href="#Thebes.text3D-Tuple{Any,Point3D}"><code>Thebes.text3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">text3D(str, pt::Point3D;
    halign=:left,
    valign=:baseline,
    rotation = (0, 0, 0)))</code></pre><p>Draw text at point <code>pt</code>, lying in the plane of the x axis. Angles in <code>rotation</code> can rotate the text away from the x plane around the x, y, and z axes.</p><p>Uses current <code>fontface()</code> and <code>fontsize()</code> settings.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tools/">« Tools</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 September 2020 11:48">Friday 18 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
