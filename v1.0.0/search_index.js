var documenterSearchIndex = {"docs":
[{"location":"functionindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"functionindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"functionindex/","page":"Index","title":"Index","text":"Modules = [Thebes]\nOrder   = [:function, :type]","category":"page"},{"location":"functionindex/#Luxor.between","page":"Index","title":"Luxor.between","text":"between(p1::Point3D, p2::Point3D, x=0.5)\nbetween((p1::Point3D, p2::Point3D), x=0.5)\n\nFind a point on a line between two 3D points. If x is 0.5, the returned point should be halfway between them.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Luxor.distance-Tuple{Point3D, Point3D}","page":"Index","title":"Luxor.distance","text":"distance(p1::Point3D, p2::Point3D)\n\nReturn the distance between two points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Luxor.drawpath-Tuple{Path, Real, Point3D}","page":"Index","title":"Luxor.drawpath","text":"drawpath(path::Path, k::Real, anchor::Point3D;\n    about=Point3D(0., 0., 0.),\n    rotation::Rotation=RotXYZ(0, 0, 0),\n    steps=20, # used when approximating Bezier curve segments\n    action=:none,\n    startnewpath=true,\n    pathlength = 0.0)\n\nDraw a Luxor Path object on a 2D plane, starting at anchor with rotation about about.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Luxor.midpoint-Tuple{Point3D, Point3D}","page":"Index","title":"Luxor.midpoint","text":"midpoint(pt1::Point3D, pt2::Point3D)\n\nFind the midpoint between two points. See also between().\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.anglebetweenvectors-Tuple{Point3D, Point3D}","page":"Index","title":"Thebes.anglebetweenvectors","text":"anglebetweenvectors(v1::Point3D, v2::Point3D)\n\nCalclate the angle between two vectors.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.axes3D","page":"Index","title":"Thebes.axes3D","text":"axes3D(n=100)\n\nDraw labelled 3D axes at (0, 0, 0) with length n.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.carpet","page":"Index","title":"Thebes.carpet","text":"carpet(n; kind=:circular)\n\nDraw a circular carpet centered at the origin, using current Luxor parameters.\n\nIf kind is not :circular, the carpet will be a square.\n\nPoints that can't be rendered are not included in the final shape.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.cartesiantospherical-Tuple{Any, Any, Any}","page":"Index","title":"Thebes.cartesiantospherical","text":"cartesiantospherical(x, y, z)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of the Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.cartesiantospherical-Tuple{Point3D}","page":"Index","title":"Thebes.cartesiantospherical","text":"cartesiantospherical(pt::Point3D)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of pt.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.centerpoint-Tuple{}","page":"Index","title":"Thebes.centerpoint","text":"centerpoint()\ncenterpoint(pt::Point3D)\n\nGet or set the current center position.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.crossproduct3D-Tuple{Point3D, Point3D}","page":"Index","title":"Thebes.crossproduct3D","text":"crossproduct3D(A::Point3D, B::Point3D)\n\nFind one of these.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.dotproduct3D-Tuple{Point3D, Point3D}","page":"Index","title":"Thebes.dotproduct3D","text":"dotproduct3D(a::Point3D, b::Point3D)\n\nFinds the dot product of a and b\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.drawcube","page":"Index","title":"Thebes.drawcube","text":"drawcube(n=10, action=:stroke)\n\nDraw a cube. drawcube(1) draws a wireframe unit cube.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.eyepoint-Tuple{}","page":"Index","title":"Thebes.eyepoint","text":"eyepoint()\neyepoint(pt::Point3D)\n\nGet or set the current eye position.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.face-Tuple{Object, Any}","page":"Index","title":"Thebes.face","text":"face(o::Object, n)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.helloworld-Tuple{}","page":"Index","title":"Thebes.helloworld","text":"helloworld()\n\nReset all the things. The equivalent of typing:\n\neyepoint(100, 100, 100)\ncenterpoint(0, 0, 0)\nuppoint(0, 0, 10)\nperspective(0)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.hiddensurface-Tuple{Object}","page":"Index","title":"Thebes.hiddensurface","text":"hiddensurface(o::Object)\n\nGiven an object o, sort the faces in o.faces,  then draw filled grey polygons for each face.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.import_off_file-Tuple{Any}","page":"Index","title":"Thebes.import_off_file","text":"import_off_file(fname)\n\nImport a file in OFF (Object File Format).\n\nReturns a Tuple - vertices, and faces. Vertices is a vector of [x, y, z], and faces a vector of vectors of vertex numbers. \n\noff_file = raw\"\n    OFF\n    8 6 0\n    -0.500000 -0.500000 0.500000\n    0.500000 -0.500000 0.500000\n    -0.500000 0.500000 0.500000\n    0.500000 0.500000 0.500000\n    -0.500000 0.500000 -0.500000\n    0.500000 0.500000 -0.500000\n    -0.500000 -0.500000 -0.500000\n    0.500000 -0.500000 -0.500000\n    4 0 1 3 2\n    4 2 3 5 4\n    4 4 5 7 6\n    4 6 7 1 0\n    4 1 7 5 3\n    4 6 0 2 4\n\"\n\nf = open(\"/tmp/cube.off\", \"w\") do f\n    write(f, off_file)    \nend\n\n@draw begin\n    o = make(import_off_file(\"/tmp/cube.off\"))\n    scaleby!(o, 100)\n    pin(o)\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.magnitude-Tuple{Point3D}","page":"Index","title":"Thebes.magnitude","text":"magnitude(a::Point3D)\n\nCalculates magnitude of a.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.make","page":"Index","title":"Thebes.make","text":"make(primitive, name=\"unnamed\")\n\nprimitive contains two arrays, an array of 3D points, and an array of faces, where each face is a list of vertex numbers.\n\nReturns a Object.\n\nExample\n\nmake(Cube, \"cube\")\n\nreturns an Object object containing an array of vertices, an array of faces, and an array of labels.\n\n@draw begin\n    helloworld()\n    tol = 0.01\n    a = []\n    sethue(\"black\")\n    for t in -2pi:tol:2pi\n        push!(a, Point3D((50 + cos(5t)) * cos(3t), (50 + cos(5t)) * sin(2t), sin(5t)))\n    end\n    Knot = make((a, []), \"knot\")\n    pin(Knot, gfunction=(args...) -> begin\n        for verts in args[1].vertices\n            pin(verts)\n        end\n    end)\nend\n\nThe default gfunction expects faces - if there aren't any, use a gfunction that draws vertices.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.moveby!-Tuple{Object, Any, Any, Any}","page":"Index","title":"Thebes.moveby!","text":"moveby!(o::Object, x, y, z)\nmoveby!(o::Object, pt::Point3D)\n\nSet the position of object to Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby!-Tuple{Vector{Point3D}, Point3D}","page":"Index","title":"Thebes.moveby!","text":"moveby!(ptlist::Point3D, x, y, z)\nmoveby!(ptlist::Point3D, pt::Point3D)\n\nMove all points in the list by a vector.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby-Tuple{Object, Any, Any, Any}","page":"Index","title":"Thebes.moveby","text":"moveby(o::Object, x, y, z)\nmoveby(o::Object, pt::Point3D)\n\nSet the position of a copy of the object to Point3D(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.moveby-Tuple{Point3D, Point3D}","page":"Index","title":"Thebes.moveby","text":"moveby(pt::Point3D, d::Point3D)\n\nReturn a new point that's the result of moving a point pt by a vector d.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.newprojection","page":"Index","title":"Thebes.newprojection","text":"newprojection(ipos::Point3D, center::Point3D, up::Point3D, perspective=0.0)\n\nDefine a new Projection:\n\nipos is the eye position\ncenter is the 3D point to appear in the center of the 2D image\nup is a point that is to appear vertically above the center\n\nIf perspective is 0.0 (the default) the projection is parallel. Otherwise it's a vague magnification factor for perspective projections.\n\nThe three vectors U, V, W, and the three scalar products, ue, ve, and we:\n\nU is at right angles to line of sight w, and to t-e, so it corresponds to\n\nthe x axis of the 2D image\n\nV is at right angles to u and to the line of sight, so it's the y axis of the\n\n2D image\n\nW is the line of sight\nwe is the projection of the eye position onto w\nue is the projection of the eye position onto that x-axis\nve is the projection of the eye position onto that y axis\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.objecttopoly-Tuple{Object}","page":"Index","title":"Thebes.objecttopoly","text":"objecttopoly(o::Object)\n\nReturn a tuple:\n\nan array of 2D points representing the vertices of o\nan array of 2D polygons representing the faces of o\n\nExample\n\nThis example draws the faces of a cube in colors, and marks the vertices in black.\n\nusing Luxor, Thebes\n\n@draw begin\n    helloworld()\n    o = make(Cube)\n    scaleby!(o, 100, 100, 100)\n    vs, fs = objecttopoly(o)\n    setopacity(0.4)\n    sethue(\"black\")\n    for face in fs\n        randomhue()\n        poly(face, :fill)\n    end\n    sethue(\"black\")\n    circle.(vs, 3, :fill)\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.perspective-Tuple{}","page":"Index","title":"Thebes.perspective","text":"perspective()\nperspective(n)\n\nGet or set the current  perspective.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Object}","page":"Index","title":"Thebes.pin","text":"pin(o::Object;\n    gfunction=(o) -> hiddensurface(o))\n\nDraw a rendering of an object.\n\nThe default rendering function is hiddensurface().\n\nYou can also use the built-in wireframe() rendering function.\n\nExamples\n\n@draw begin\n    o = make(Cube)\n    axes3D(200)\n    scaleby!(o, 200, 200, 200)\n    eyepoint(250, 270, 300)\n    pin(o) # use an attempted hiddensurface rendering\n\n    o = make(Tetrahedron)\n    axes3D(200)\n    scaleby!(o, 200, 200, 200)\n    eyepoint(250, 270, 300)\n    pin(o, gfunction=wireframe) # use a wireframe rendering\nend\n\nMore help\n\nYou could write your own rendering function to draw objects.\n\nfunction a_rendering_function(o::Object)\n   if !isempty(o.faces)\n       sortfaces!(o)\n       @layer begin\n           for (n, face) in enumerate(o.faces)\n               @layer begin\n                   vertices = o.vertices[face]\n                   sn = surfacenormal(vertices)\n                   ang = anglebetweenvectors(sn, eyepoint())\n                   setgrey(rescale(ang, 0, π, 1, 0))\n                   pin(vertices, gfunction = (p3, p2) ->\n                    begin\n                       poly(p2, :fill)\n                       sethue(\"white\")\n                       poly(p2, :stroke, close=true)\n                    end)\n               end\n           end\n       end\n   end\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Point3D, Point3D}","page":"Index","title":"Thebes.pin","text":"pin(p3_1::Point3D, p3_2::Point3D;\n    gfunction = ((p3_1, p3_2), (p2_1, p2_2)) ->\n        line(p2_1, p2_2, :stroke))\n\nDraw two 3D points.\n\nThe default action is to draw a line between two points.\n\nThe gfunction can access the 3D points as the first argument, the two 2D points in the second argument.\n\npin(p, Point3D(50cos(θ), 50sin(θ), p.z),\n    gfunction = (p3s, p2s) -> begin\n        line(p2s..., :stroke)\n    end)\n\n\nReturns the two 2D points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Point3D}","page":"Index","title":"Thebes.pin","text":"pin(pt::Point3D;\n    gfunction = (p3, p2) -> circle(p2, 1, :stroke))\n\nDraw a single 3D point on the current Luxor drawing.\n\nThe default graphic is a circle. You can define others using a custom gfunction, which takes two arguments: the 3D point and its 2D counterpoint.\n\nFor example, this draws a circle whose radius is larger if the point is nearer to the eye.\n\npin(p, gfunction = (p3, p2) -> begin\n        d = distance(p3, eyepoint())\n        circle(p2, rescale(d, 0, 300, 20, 5), :fill)\n    end\n    )\n\nReturns the 2D point.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pin-Tuple{Vector{Point3D}}","page":"Index","title":"Thebes.pin","text":"pin(p3list::Array{Point3D, 1};\n    gfunction = (p3list, p2list) ->\n        poly(p2list, :stroke, close=true))\n\nDraw an array of 3D points.\n\nThe default action is to draw a polygon through all the points.\n\nThe gfunction can access the 3D points as the first argument, the two 2D points in the second argument.\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 20θ) for θ in 0:π/12:4π]\na_box = pin(helix, gfunction =\n    (p3list, p2list) -> prettypoly(p2list, :stroke)\n    )\n\nReturns the list of 2D points.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.pointsperpendicular","page":"Index","title":"Thebes.pointsperpendicular","text":"pointsperpendicular(p1::Point3D, p2::Point3D, radius, angles = [0, π])\n\nFind points perpendicular to a line joining p1 and p2. Points are radius units away from the line.\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Thebes.project-Tuple{Point3D}","page":"Index","title":"Thebes.project","text":"project(P::Point3D)\n\nProject a 3D point onto a 2D surface, as defined by the current projection.\n\nTODO Currently this returns 'nothing' if the point is behind the eyepoint. This makes handling the conversion a bit harder, though, since the function now returns either a 2D Luxor point or nothing.\n\nusing Thebes, Luxor\n\n@svg begin\n    eyepoint(Point3D(250, 250, 100))\n    centerpoint(Point3D(0, 0, 0))\n    uppoint(Point3D(0, 0, 10))\n    sethue(\"grey50\")\n    carpet(300)\n    axes3D(100)\n    sethue(\"red\")\n    for i in 1:30\n        randpoint3D = Point3D(rand(0.0:150, 3)...)\n        sethue(\"red\")\n        pt1 = pin(randpoint3D)\n        if pt1 != nothing\n            circle(pt1, 5, :fill)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateX-Tuple{Point3D, Any}","page":"Index","title":"Thebes.rotateX","text":"rotateX(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the x axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateY-Tuple{Point3D, Any}","page":"Index","title":"Thebes.rotateY","text":"rotateY(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the y axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateZ-Tuple{Point3D, Any}","page":"Index","title":"Thebes.rotateZ","text":"rotateZ(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the z axis by an angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Object, Any, Any, Any}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(o::Object, r::Rotation)\nrotateby!(o::Object, angleX, angleY, angleZ)\n\nRotate an object through rotation r, or around the x, y, and/or z axis by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Object, Point3D, Any, Any, Any}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby!(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate an object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Vector{Point3D}, Float64, Float64, Float64}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\n\nModify a list of points by rotating each one around the x, y, and z axes by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby!-Tuple{Vector{Point3D}, Point3D, Float64, Float64, Float64}","page":"Index","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(ptlist::Array{Point3D, 1}, r::Rotation=RotXYZ{Float64})\n\nRotate each point in the list by rotation (or angleX, angleY, angleZ) around another point (or origin).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Object, Any, Any, Any}","page":"Index","title":"Thebes.rotateby","text":"rotateby(o::Object, angleX, angleY, angleZ)\n\nRotate a copy of the object by angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Object, Point3D, Any, Any, Any}","page":"Index","title":"Thebes.rotateby","text":"rotateby(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate a copy of the object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Point3D, Float64, Float64, Float64}","page":"Index","title":"Thebes.rotateby","text":"rotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(point::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\n\nReturn a new point/list of points resulting from rotating around the x, y, and z axes by angleX, angleY, angleZ.\n\nThe Z rotation is first, then the Y, then the X.\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XYZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.rotateby-Tuple{Point3D, Point3D, Float64, Float64, Float64}","page":"Index","title":"Thebes.rotateby","text":"rotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.scaleby!-Tuple{Object, Any, Any, Any}","page":"Index","title":"Thebes.scaleby!","text":"scaleby!(o::Object, x, y, z)\n\nScale object by x in x, y in y, and z in z.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.scaleby!-Tuple{Object, Any}","page":"Index","title":"Thebes.scaleby!","text":"scaleby!(o::Object, d)\n\nScale object by d in x, d in y, and d in z.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.scaleby!-Tuple{Vector{Point3D}, Any, Any, Any}","page":"Index","title":"Thebes.scaleby!","text":"scaleby!(ptlist::Array{Point3D, 1}, x, y, z)\n\nScales a list of points by multiplying by x in X, y in Y, z in Z.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.sortfaces!-Tuple{Object}","page":"Index","title":"Thebes.sortfaces!","text":"sortfaces!(o::Object;\n    eyepoint::Point3D=eyepoint())\n\nFind the averages of the z values of the faces in Object, and sort the faces of o so that the faces are in order of nearest (highest) z relative to eyepoint...\n\nor something like that ? not sure how this works\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.sphericaltocartesian-Tuple{Any, Any, Any}","page":"Index","title":"Thebes.sphericaltocartesian","text":"sphericaltocartesian(ρ, θ, ϕ)\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ):\n\nρ is the distance from the origin (ie radius)\nθ is the azimuthal angle (the longitude) 0 is +x, π is -x, 2π is +x\nϕ is the polar angle (the latitude) 0 is North Pole, π is South Pole\n\nThere are two major conventions for spherical coordinate notation.\n\nIn physics books:\n\n(ρ, θ, φ) gives the radial distance, polar angle (latitude), and azimuthal angle (longitude)\n\nIn mathematics books:\n\n(ρ, θ , φ ) gives the radial distance, azimuthal angle (longitude), and polar angle (latitude)\n\nSo we're using the mathematics one here.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.sphericaltocartesian-Tuple{Any}","page":"Index","title":"Thebes.sphericaltocartesian","text":"sphericaltocartesian((ρ, θ, ϕ))\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ).\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.surfacenormal-Tuple{Vector{Point3D}}","page":"Index","title":"Thebes.surfacenormal","text":"surfacenormal(ptlist::Array{Point3D, 1})\n\nFinds one of these.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.text3D-Tuple{Any, Point3D}","page":"Index","title":"Thebes.text3D","text":" text3D(str, anchor::Point3D;\n    halign=:left,\n    valign=:baseline,\n    about=Point3D(0., 0., 0.),\n    rotation::Rotation=RotXYZ(0, 0, 0))\n\nDraw text at point pt, lying in the plane of the x axis. Angles in rotation rotate the text about the about point, defaulting to Point3D(0, 0, 0).\n\nUses Luxor's fontface() and fontsize() settings.\n\nSpecify rotations using functions from Rotations.jl, such as:\n\nRotX(a)\nRotZ(a)\nRotXZ(a1, a2)\nRotXYZ(a1, a2, a3)\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.uppoint-Tuple{Point3D}","page":"Index","title":"Thebes.uppoint","text":"uppoint(pt::Point3D)\n\nSpecify the \"up\" direction for the world: a line from the centerpoint to the uppoint defines the up direction.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.uppoint-Tuple{}","page":"Index","title":"Thebes.uppoint","text":"uppoint()\nuppoint(pt::Point3D)\n\nThe \"up\" direction for the world: a line from the centerpoint to the uppoint defines the up direction.\n\n\n\n\n\n","category":"method"},{"location":"functionindex/#Thebes.wireframe-Tuple{Object}","page":"Index","title":"Thebes.wireframe","text":"wireframe(o::Object)\n\nGiven an object o, sort the faces in o.faces,  then draw grey stroked polygons for each face.    \n\n\n\n\n\n","category":"method"},{"location":"objects/","page":"Objects","title":"Objects","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"objects/#Objects","page":"Objects","title":"Objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"So far we’ve been drawing individual points, lines, and polygons. pin() has been projecting them all onto the current drawing. ","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"You can also draw an object. This lets us complete the pin-table:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":" pin() arguments the gfunction arguments\npoint pin(p1::Point3D) (p3::Point3D, p2::Point)\nline pin(p1::Point3D, p2::Point3D) ((p31::Point3D, p32::Point3D), (p21::Point, p22::Point))\npolygon pin(a::Vector{Point3D}) (a1::Vector{Point3D}, a2::Vector{Point})\nobject pin(o::Object) (o::Object)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"An object is a collection of 3D points and a list of faces - which vertices are joined to form a face.","category":"page"},{"location":"objects/#Making-objects-with-make","page":"Objects","title":"Making objects with make","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"You can make a 3D object using make(), and then use pin() to project it onto the 2D drawing.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"make() expects an array of 3D points, an (optional) array of face definitions, and an (optional) array of labels, plus an (optional) name. These arrays let you link faces with vertices. It returns an Object.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Information about cubes is already defined in Thebes (we needn't have made one earlier, really) as Cube, a tuple of Point3Ds and face definitions. You can make a cube object from this data with:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"cube = make(Cube, \"cube\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Now the cube variable contains:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Object(\n    Point3D[\n        Point3D(-0.5, 0.5, -0.5),\n        Point3D(0.5, 0.5, -0.5),\n        Point3D(0.5, -0.5, -0.5),\n        Point3D(-0.5, -0.5, -0.5),\n        Point3D(-0.5, 0.5, 0.5),\n        Point3D(0.5, 0.5, 0.5),\n        Point3D(0.5, -0.5, 0.5),\n        Point3D(-0.5, -0.5, 0.5)\n    ],\n\n    [[1, 2, 3, 4],\n     [2, 6, 7, 3],\n     [6, 5, 8, 7],\n     [5, 1, 4, 8],\n     [1, 5, 6, 2],\n     [4, 3, 7, 8]],\n\n     [1, 2, 3, 4, 5, 6],\n\n     \"cube\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"There are 8 3D points. And there are 6 faces defined. Face 1 is formed by vertices 1, 2, 3, and 4, face 2 is formed by vertices 2, 6, 7, and 3, and so on. The default rendering applied by pin(o::Object) is an attempt at a simple hidden-surface display. ","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\nhelloworld() # hide\neyepoint(2, 2, 2)\nperspective(500)\ncube = make(Cube, \"cube\")\npin(cube)\n\nend 800 400","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"note: Note\nIn real 3D software such as Makie.jl, the rendering is much more sophisticated!","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The default gfunction for this method of pin is hiddensurface, which is built in to Thebes as Thebes.hiddensurface(o::Object).  We could call:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"    pin(cube, gfunction = hiddensurface)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"to specify the rendering function explicitly.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Another built-in gfunction is wireframe(o::Object):","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n@drawsvg begin\n    background(\"grey20\") # hide\n    helloworld() # hide\n    eyepoint(2, 2, 2)\n    perspective(500)\n    sethue(\"gold\")\n    cube = make(Cube, \"cube\")\n    pin(cube, gfunction = wireframe)\nend 800 400","category":"page"},{"location":"objects/#Making-objects-directly","page":"Objects","title":"Making objects directly","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's a very simple example of how you might make your own object from scratch. We'll make a heptagonal pyramid, setting N to 7.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\nsetlinejoin(\"bevel\")\nhelloworld() # hide\ncarpet(200)\nvertices = Point3D[]\n\n# heptagonal = 7\nN = 7\n\n# make the base\npolygon = ngon(O, 150, N, vertices=true)\nfor i in eachindex(polygon)\n    push!(vertices, convert(Point3D, polygon[i]))\nend\n\n# add the tip 200 units above the base\npush!(vertices, Point3D(0, 0, 200))\n\n# make the faces\nfaces = Vector{Int64}[]\nfor i in eachindex(polygon)\n    push!(faces, [i, mod1(i + 1, N), N + 1])\nend\n\nobj = make([vertices, faces], \"\")\nsetopacity(0.8)\npin(obj, gfunction = hiddensurface)\nend 800 600","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"First we pushed the vertices into an array, then added the top vertex as the N + 1th. The faces array is filled with lists such as [1, 2, N], [2, 3, N] to make the sides. Finally the make() function takes the vertices and faces and returns an Object.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The pyramid doesn't have a base. To add one, add the line:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"push!(faces, 1:N)","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"just before the make() function builds the object.","category":"page"},{"location":"objects/#Using-objects","page":"Objects","title":"Using objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"Thebes has a few 3D coordinate sets pre-defined that you can use with make():","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor, Colors # hide\n\n@drawsvg begin\nbackground(\"grey20\") # hide\nsetlinejoin(\"bevel\")\nhelloworld() # hide\nperspective(250)\neyepoint(2, 2, 2)\n\nsetopacity(0.8)\n\npts = between.(boxmiddleleft(), boxmiddleright(), range(0.1, 0.9, length=4))\nfor (n, o) in enumerate((Cube, Pyramid, Tetrahedron, Teapot))\n    @layer begin\n        translate(pts[n])\n        pin(make(o))\n    end\nend\nend 800 300","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"These are automatically imported (from data/objects.jl) when Thebes.jl starts:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Cube\nTetrahedron\nPyramid\nTeapot","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The teapot is a thing in the world of 3D modelling, apparently.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n@drawsvg begin\n    background(\"grey20\") # hide\n    helloworld() # hide\n    perspective(500)\n    eyepoint(200, 200, 150)\n    carpet(200)\n    axes3D()\n    teapot = make(Teapot)\n    setline(0.5)\n    sethue(\"white\")\n    scaleby!(teapot, 100, 100, 100)\n    pin(teapot, gfunction=hiddensurface)\nend 800 400","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"You can load more objects by including the moreobjects.jl file from the data folder:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"include(dirname(dirname(pathof(Thebes))) * \"/data/moreobjects.jl\")","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"which brings these objects into play:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"boxcube boxtorus concave cone crossshape cube cuboctahedron dodecahedron geodesic helix2 icosahedron icosidodecahedron octahedron octtorus rhombicosidodecahedron rhombicuboctahedron rhombitruncated_cubeoctahedron rhombitruncated_icosidodecahedron snub_cube snub_dodecahedron sphere2 tet3d tetrahedron triangle truncated_cube truncated_dodecahedron truncated_icosahedron truncated_octahedron truncated_tetrahedron","category":"page"},{"location":"objects/#Rendering-objects","page":"Objects","title":"Rendering objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"note: Note\nRendering objects realistically is not something that Thebes really bothers with - there are many better options for this task. ","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"There are many choices you can make about how to draw the faces and the vertices of an object.","category":"page"},{"location":"objects/#Writing-gfunctions","page":"Objects","title":"Writing gfunctions","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"The gfunction for pin(o::Object) determines the rendering style for an object.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's a simple example of a custom gfunction:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n\nfunction mygfunction(o::Object)\n    sortfaces!(o)\n    if !isempty(o.faces)\n        @layer begin\n            for (n, face) in enumerate(o.faces)\n                @layer begin\n                    vertices = o.vertices[face]\n                    sn = surfacenormal(vertices)\n                    ang = anglebetweenvectors(sn, eyepoint())\n                    setgrey(rescale(ang, 0, π, 0, 1))\n                    pin(vertices, gfunction=(p3, p2) -> poly(p2, :fill))\n                end\n            end\n        end\n    end\nend\n\ninclude(dirname(pathof(Thebes)) * \"/../data/moreobjects.jl\")\n\nobject = make(geodesic, \"geodesic\")\n\n@draw begin\n    background(\"grey20\") # hide\n    helloworld() # hide\n    setlinejoin(\"bevel\")\n    eyepoint(200, 200, 200)\n    pin(scaleby!(object, 300, 300, 300), gfunction=mygfunction)\nend 800 800","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"pin(o::Object) here calls mygfunction(o::Object) to render object o. First, the sortfaces(o::Object) function sorts the faces in the object o so that the ones that are furthest from the eyepoint are stored first. Then the surface normal of each face is calculated, and the angle between the surface normal and a line to the eyepoint determines the color of the face. ","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The surface normal is an imaginary line that meets the face at right angles, and thus indicates the direction of that face. If you measure the angle between the surface normal and the direction of a line from the origin to the eye point, you can obtain a value that indicates the orientation of the face relative to the eye point. You can then use this to control the rendering: an angle approaching π suggests that the facet is almost facing the viewer, and you can color it accordingly.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: surface normal)","category":"page"},{"location":"objects/#Using-custom-code","page":"Objects","title":"Using custom code","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"Thebes.jl is a toy rather than a full 3D renderer, and a general-purpose rendering function that draws everything with lots of optional parameters is not provided. There are plenty of ways to experiment though.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Suppose you want to remove the front-facing faces of an object, in order to see inside. That's possible, but a bit of code is needed.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes\nusing Luxor\nusing Rotations\n\nfunction mygfunction(o::Object)\n    sortfaces!(o)\n    if !isempty(o.faces)\n        @layer begin\n            for (n, face) in enumerate(o.faces)\n                @layer begin\n                    vertices = o.vertices[face]\n                    sn = surfacenormal(vertices)\n                    ang = anglebetweenvectors(sn, eyepoint())\n                    setgrey(rescale(ang, 0, π, 0, 1))\n                    pin(vertices, gfunction=(p3, p2) -> poly(p2, :fillpreserve))\n                    sethue(\"grey20\")\n                    strokepath()\n                end\n            end\n        end\n    end\nend\n\nfunction cullfrontfaces!(m::Object, angle;\n        eyepoint::Point3D=eyepoint())\n    avgs = Float64[]\n    for face in m.faces\n        vertices = m.vertices[face]\n        s = 0.0\n        for vertex in vertices\n            s += distance(vertex, eyepoint)\n        end\n        average = s / length(unique(vertices))\n        θ⃗ = surfacenormal(vertices)\n        if anglebetweenvectors(θ⃗, eyepoint) > angle\n            push!(avgs, average)\n        end\n    end\n    neworder = sortperm(avgs)\n    m.faces = m.faces[neworder]\n    m.labels = m.labels[neworder]\n    return m\nend\n\n@drawsvg begin\n    helloworld()\n    setlinejoin(\"bevel\")\n    setline(0.5)\n    setopacity(0.8)\n    include(dirname(pathof(Thebes)) * \"/../data/moreobjects.jl\")\n    shape = icosidodecahedron\n    objectfull = make(shape, \"the full object\")\n    objectcut = make(shape, \"the cut-open object\")\n    map(o -> scaleby!(o, 150, 150, 150), (objectfull, objectcut))\n    sortfaces!.((objectcut, objectfull))\n    cullfrontfaces!(objectcut, π / 3)\n    translate(-200, 0)\n    pin(objectcut, gfunction=mygfunction)\n    translate(400, 0)\n    pin(objectfull, gfunction=mygfunction)\nend 800 600","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The object on the left has had its frontfacing faces removed. The one on the right is intact.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"note: Note\n","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"There are probably better ways to do this...!","category":"page"},{"location":"objects/#OFF-the-shelf-objects","page":"Objects","title":"OFF the shelf objects","text":"","category":"section"},{"location":"objects/","page":"Objects","title":"Objects","text":"There are many formats for exchanging 3D data between software applications. Thebes.jl knows about one of these formats, the Object File Format (.OFF). You'll find a few objects already made for you to use directly.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's what a typical OFF file, \"cube.off\", looks like:","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"OFF\n8 6 0\n-0.500000 -0.500000 0.500000\n0.500000 -0.500000 0.500000\n-0.500000 0.500000 0.500000\n0.500000 0.500000 0.500000\n-0.500000 0.500000 -0.500000\n0.500000 0.500000 -0.500000\n-0.500000 -0.500000 -0.500000\n0.500000 -0.500000 -0.500000\n4 0 1 3 2\n4 2 3 5 4\n4 4 5 7 6\n4 6 7 1 0\n4 1 7 5 3\n4 6 0 2 4","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"The file contains 8 3D points, defined as three numbers, followed by the definitions of 6 faces. The first face 4 0 1 3 2 has 4 vertices, and joins vertices 0 (on line 3), 1, 3, and 2.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"To load the contents of the OFF file into an object, use import_off_file().","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"Here's an example that loads an OFF file of the mask of Tutenkhamun (whicn can be found in the Thebes data directory) and rotates it.","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"using Thebes, Luxor # hide\n\nfunction frame(scene, framenumber, o)\n    eased_n = rescale(scene.easingfunction(framenumber, 0, 1,\n            scene.framerange.stop), 0, 1, 0, 2π)\n    helloworld()\n    perspective(300)\n    eyepoint(200cos(eased_n), 200sin(eased_n), 80)\n    background(\"grey20\")\n    setlinejoin(\"bevel\")\n    setline(0.2)\n    pin(o)\nend\n\nfunction main()\n    scaleby!(o, 15)\n    moveby!(o, 0, 0, -150)\n    amovie = Movie(800, 600, \"tut\")\n    animate(amovie,\n        Scene(amovie, (s, f) -> frame(s, f, o), 1:100),\n        framerate=15,\n        creategif=true)\nend\n\nf = dirname(dirname(pathof(Thebes))) * \"/data/tut.off\"\no = make(import_off_file(f))\nmain()","category":"page"},{"location":"objects/","page":"Objects","title":"Objects","text":"(Image: animated Tutankhamun)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"text/#Text","page":"Text","title":"Text","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Thebes provides a text3D() function that draws text on a 2D plane in 3D space. ","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"note: Note\nFor more information about using fonts and font selection, refer to the \"Text\" chapter in the Luxor documentation.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"You specify the 3D location of the text's 'anchor' point, and optionally supply rotations and text alignment (halign etc.). By default, the text in Thebes (as in Luxor) runs along the x-axis, and lies in the xy plane.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"Use Rotations.jl to specify rotations.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Thebes, Luxor, Rotations # hide\n\n@drawsvg begin\nfontsize(50)\nbackground(\"grey20\")\nsetlinejoin(\"bevel\")\neyepoint(Point3D(250, 250, 250))\nperspective(400)\nsethue(\"white\")\naxes3D(220)\n\nfontsize(40)\nfontface(\"Georgia-Italic\")\n\ntext3D(\"the x-axis\", Point3D(0, 0, 0))\ntext3D(\"the y-axis\", Point3D(0, 0, 0), \n    rotation=RotZ(deg2rad(90)))\ntext3D(\"the z-axis\", Point3D(0, 0, 0), \n    rotation=RotX(-deg2rad(90)) * RotZ(deg2rad(90)), halign=:right)\n\nend 800 600","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"The three main differences between Luxor.text() and Thebes.text3D() are the anchor position (a Point3D), the about keyword, and the rotation keyword. ","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"You can see that the the y-axis text has been rotated around the Z axis by 90°. ","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"The the z-axis text is aligned right, so it starts off on the negative part of the x-axis. The first rotation - in the z-axis - sends the text to be aligned with the y-axis, such that the 's' is almost touching the origin. Then the 90° clockwise rotation about the x-axis lifts the text up to run along the z-axis. ","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"Rotations.jl is doing all the hard work here: in the construction RotX(...) * RotZ(...), the z-axis rotation is applied first.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"You can also use some of Luxor's text functions, such as textextents(), which helps you get the (2D) dimensions of text.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Thebes, Luxor, Colors, Rotations\nbackground(\"grey20\") # hide\n@drawsvg begin\neyepoint(Point3D(250, 250, 550))\nperspective(500)\nfontsize(50)\nte = textextents(\"Julia\")\n\nfor y in -1200:te[3]:1200\n        for x in -1200:te[4]:1200\n            sethue(HSB(mod(x*y, 360), .6, .9))\n            text3D(\"Julia\", Point3D(x, y, 0), about=Point3D(x, y, 0), rotation=RotZ(π/2))\n        end\n    end\n\nend 800 800","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"It's also possible to write math equations in LaTeX by passing a LaTeXString to the text function. Thebes (and Luxor) use MathTeXEngine.jl and LaTeXStrings.jl to parse the LaTeXString. ","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Thebes\nusing Luxor\nusing Rotations\nusing MathTeXEngine\nusing LaTeXStrings\n\n@svg begin\n    background(0.0, 0.05, 0.1)\n    helloworld()\n    perspective(500)\n    eyepoint(300, 300, 250)\n    sethue(\"white\")\n    fontsize(30)\n    setline(1)\n    for z in -150:10:50\n        setopacity(z < 50 ? 0.2 : 1)\n        e = L\"e^{i\\pi} + 1 = 0\"\n        for i in 0:π/12:2π-π/12\n            text3D(e,\n                sphericaltocartesian(100, i, π / 2) + Point3D(0, 0, z),\n                about = sphericaltocartesian(100, i, π / 2),\n                rotation = RotZ(i))\n        end\n    end\nend 800 600 \"/tmp/text3.svg\"","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: LaTeX 3D text)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"text3D","category":"page"},{"location":"text/#Thebes.text3D","page":"Text","title":"Thebes.text3D","text":" text3D(str, anchor::Point3D;\n    halign=:left,\n    valign=:baseline,\n    about=Point3D(0., 0., 0.),\n    rotation::Rotation=RotXYZ(0, 0, 0))\n\nDraw text at point pt, lying in the plane of the x axis. Angles in rotation rotate the text about the about point, defaulting to Point3D(0, 0, 0).\n\nUses Luxor's fontface() and fontsize() settings.\n\nSpecify rotations using functions from Rotations.jl, such as:\n\nRotX(a)\nRotZ(a)\nRotXZ(a1, a2)\nRotXYZ(a1, a2, a3)\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"The basics","title":"The basics","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"basics/#The-basics","page":"The basics","title":"The basics","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Thebes.jl is a small package that adds some simple 3D features to Luxor.jl (a vector-graphics package for graphics workers who like to automate their work with Julia).","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"warning: Warning\nRemember: Thebes.jl is intended for simple wireframe constructions in 3D. Don't expect a comprehensive range of 3D modelling and rendering tools. Use Makie.jl (or Blender)!","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The 3D world of Thebes is superimposed on the 2D world of Luxor:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor\n\n@drawsvg begin  # a Luxor macro\n    background(\"grey20\") # a Luxor function\n    rulers()             # a Luxor function\n    axes3D()             # a Thebes function\nend","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"There are two main things you have to know in order to draw in 3D:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"the Point3D type specifies the x, y, and z coordinates of a point in 3D space.\nthere's a function called pin() that draws 2D graphics on the Luxor drawing at the position corresponding to the 3D point.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nThe pin() function (“<b>p</b>roject <b>in</b>to 2D” perhaps) “pins” 3D information onto the flat 2D drawing surface. I wanted to avoid everything obvious, like “draw”, “render”, “display”, “plot”, “show”, or whatever, and have something short and easy to type. Not to be confused with Pkg.pin().","category":"page"},{"location":"basics/#A-simple-example","page":"The basics","title":"A simple example","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Here's a complete example showing Thebes and Luxor working together:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor\nd = Drawing(800, 300, \"assets/figures/simpleexample.svg\") # a drawing is required\nbackground(\"grey20\")     # Luxor\norigin()                 # Luxor\nsetline(1)               # Luxor\nsethue(\"white\")          # Luxor\naxes3D()                 # Thebes\n\np1 = Point3D(100, 20, 0) # Thebes\n\nloc = pin(p1)            # Thebes  \n\n\nlabel(\"there it is!\", :e, loc + (5, 0), offset=10, leader=true)  # Luxor\n\nfinish()                 # Luxor\nd # hide","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The pin function draws a small circle at the 3D point p1 and this also returns the corresponding 2D point, which is stored in loc and can be used like any other Luxor 2D point.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nBecause Thebes.jl displays 3D points on the current 2D Luxor drawing, you should always have a current drawing before using most of the functions from Thebes.","category":"page"},{"location":"basics/#Point-cloud","page":"The basics","title":"Point cloud","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"We can do lots of points - here's a few thousand.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n@draw begin\nhelloworld() # hide\norigin() # hide\nbackground(\"grey20\")\nsetopacity(0.5)\nsethue(\"gold\")\nc = pin.([Point3D(randn() * 70, randn() * 70, randn() * 70)\n    for x in 1:50, y in 1:50, z in 1:50])\naxes3D()\nfinish() # hide\nend 800 600","category":"page"},{"location":"basics/#Helical-dots","page":"The basics","title":"Helical dots","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Let's draw a helix with dots:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\nhelloworld() # hide\naxes3D()\n\nsethue(\"white\")\nhelix = [Point3D(150cos(θ), 150sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix)\nend 800 500","category":"page"},{"location":"basics/#gfunctions","page":"The basics","title":"gfunctions","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"The default graphical rendition of a 3D point is pretty basic: a circle. But you can modify the graphics drawn at each location by passing a function to the pin() function's optional keyword argument, gfunction.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"Suppose you want to draw a randomly colored circle at the location of each 3D point, with radius 5 units.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\naxes3D()\n\nhelix_pts = [Point3D(150cos(θ), 150sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix_pts, gfunction = (_, pt) -> begin\n    randomhue()\n    circle(pt, 5, :fill)\n    end)\n\nend 800 500","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The anonymous function passed to gfunction expects two arguments: the first contains the 3D point, the second contains the 2D point. The function then has the responsibility to draw the 2D graphics for that 2D point, with the possibility of using anything or nothing about the original 3D coordinates. This gives us more control over the rendering of the points.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"If you just want simple Luxor stars, you use the second (2D) argument - you don't need the first (3D) one, and we can use the convention of having _ to signify that.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(150cos(θ), 150sin(θ), 10θ) for θ in 0:π/24:4π]\n\npin.(helix, gfunction = (_, pt) -> begin\n    randomhue()\n    star(pt, 5, 5, 0.5, 0.0, :fill)\n    end)\n\nend 800  500","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In this next example, the gfunction calculates the distance of the 3D point from the 3D origin, and then draws the 2D circle with a radius that reflects that distance. The function therefore requires both the original 3D point (in the first argument p3) and the second argument (in p2), its 2D projection.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\naxes3D(100)\n\nhelix = [Point3D(100cos(θ), 100sin(θ), 10θ) for θ in 0:π/24:4π]\n\nsethue(\"orange\")\n\npin.(helix, gfunction = (p3, p2) -> begin\n    d = rescale(distance(p3, Point3D(0, 0, 0)), 100, 200, 1, 10)\n    circle(p2, d, :fill)\n    end)\n\nend 800 500","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nRemember that all the graphics drawn are 2D graphics. This isn't real 3D, remember! The human brain is quite adaptable, though.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In the next example, each random 3D point is drawn twice, the second time using zero for the z coordinate, to make shadows.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n\n@drawsvg begin\nbackground(\"grey10\") # hide\neyepoint(Point3D(250, 250, 100)) # hide\nsethue(\"grey50\") # hide\ncarpet(300)\naxes3D(100)\nsethue(\"gold\")\nfor i in 1:300\n    randpoint3D = Point3D(rand(0.0:200, 3)...)\n    sethue(\"red\")\n    pin(randpoint3D,\n        gfunction = (_, p2) -> circle(p2, 2, :fill))\n    sethue(\"grey30\")\n    pin(Point3D(randpoint3D.x, randpoint3D.y, 0),\n        gfunction = (_, p2) -> circle(p2, 2, :fill))\nend\nend 800 500","category":"page"},{"location":"basics/#Lines","page":"The basics","title":"Lines","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"Dots are all very well, but suppose we wanted to draw lines? pin() also accepts two 3D points.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"This code uses the same 3D points in the helix, but this time draws a line from each projected 2D point to the projection of the nearest point on the vertical z axis.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(200cos(θ), 200sin(θ), 15θ) for θ in 0:π/48:4π]\n\nsetline(0.5)\nsethue(\"gold\")\n\nfor p in helix\n    pin(p, Point3D(0, 0, p.z))\nend\n\nend 800 500","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"The default gfunction's arguments for this pin method consist of two pairs of points (a pair of 3D points, and a pair of 2D points), not just two of each, and Luxor's trusty line() function is the default action, connecting the 2D pair.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"Or you could provide a custom gfunction to draw multicoloured arrows instead:","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\naxes3D()\n\nhelix = [Point3D(200cos(θ), 200sin(θ), 15θ) for θ in 0:π/48:4π]\n\nfor p in helix\n    pin(p, Point3D(0, 0, p.z), gfunction = (p3p, p2p) ->\n        begin\n            randomhue()\n            arrow(last(p2p), first(p2p))\n        end)\nend\n\nend 800 500","category":"page"},{"location":"basics/#When-things-go-wrong","page":"The basics","title":"When things go wrong","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"In 2D graphics, things sometimes go wrong when values get close to zero or infinity. The same thing is true for 3D too, when the coordinates start stressing out the projecting equations. Really good 3D software will prevent this happening. In Thebes, though, you may occasionally see glitches. You're only seeing half the \"world\" that's in front of you  - there's nearly a whole half-world falling behind the eye position, and this means that some points don't get drawn succesfully.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"In general, if the pin() function can't display points or lines, it will probably just discard them and carry on, rather than attempt to draw things in impossible locations or straight lines that curve in space. So if you notice parts of your drawing missing, the easiest thing to do is to move the eyepoint further away from the 3D points in question.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"note: Note\nMakie.jl offers support for realistic andflexible 3D projections.","category":"page"},{"location":"basics/#Conversions","page":"The basics","title":"Conversions","text":"","category":"section"},{"location":"basics/","page":"The basics","title":"The basics","text":"The convert() function provides a useful way to convert 2D coordinates to 3D. ","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"convert(Point3D, Point(10, 30))\n3-element Point3D:\n 10.0\n 30.0\n  0.0","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"If you can generate your graphics in 2D, you can convert them to 3D, and then use pin() to project them back into two dimensions.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"This example shows how to draw the familiar Julia coloured circles. We can't use real circles (because there are no Bézier paths in Thebes yet), so we use ngon() with plenty of sides - 60 is probably good enough if your output is high-quality SVG.","category":"page"},{"location":"basics/","page":"The basics","title":"The basics","text":"using Thebes, Luxor, Rotations # hide\n\nfunction drawjuliadots3D(threedots, origin::Point3D, \n        rotation::Rotation=RotXYZ(0, 0, 0);\n        radius=100)\n    for (n, dot) in enumerate(threedots)\n        sethue([Luxor.julia_purple, Luxor.julia_green, Luxor.julia_red][mod1(n, end)])\n        d = dot .+ origin\n        rotateby!(d, origin, rotation)\n        pin(d, gfunction = (_, pts) -> poly(pts, close=true, :fill))\n    end\nend\n\nfunction juliaroom()\n    @draw begin\n    background(\"black\")\n    helloworld()\n    eyepoint(1200, 1200, 1200)\n    perspective(1200)\n\n    # create the basic three-dot shape\n    threedots = Array{Point3D, 1}[]\n    radius = 8\n    points = ngon(O, radius, 3, -π/3, vertices=true)\n    for (n, p) in enumerate(points)\n        # zcoordinate defaults to 0 in convert()\n        push!(threedots, convert.(Point3D, ngon(p, 0.75 * radius, 60)))\n    end\n\n    # draw lots in each plane\n    for x in 30:30:500\n        for y in 30:30:500\n            drawjuliadots3D(threedots, Point3D(x, y, 0), RotXYZ(0, 0, 0))\n        end\n    end\n\n    for x in 30:30:500\n        for z in 30:30:500\n            drawjuliadots3D(threedots, Point3D(x, 0, z), RotXYZ(-π/2, 0, π/2))\n        end\n    end\n\n    for y in 30:30:500\n        for z in 30:30:500\n            drawjuliadots3D(threedots, Point3D(0, y, z), RotXYZ(0, π/2, 0))\n        end\n    end\n\n    axes3D(300)\n    end 800 700\nend\n\njuliaroom()","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"polys/#Polygons-and-planes","page":"Polygons and planes","title":"Polygons and planes","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"The pin() function accepts an array of 3D points as well as singletons and pairs. In this case, the default graphical treatment is to apply the Luxor.poly(... :stroke) function to the array of projected 2D points.","category":"page"},{"location":"polys/#Mobius","page":"Polygons and planes","title":"Möbius","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor # hide\n\nfunction makemobius()\n    x(u, v) = (1 + (v / 2 * cos(u / 2))) * cos(u)\n    y(u, v) = (1 + (v / 2 * cos(u / 2))) * sin(u)\n    z(u, v) = v / 2 * sin(u / 2)\n    w = 1\n    st = 2π / 150\n    Δ = 0.1\n    result = Array{Point3D,1}[]\n    for u in 0:st:2π-st\n        for v in -w:Δ:w\n            p1 = Point3D(\n                x(u, v + Δ / 2),\n                y(u, v + Δ / 2),\n                z(u, v + Δ / 2))\n            p2 = Point3D(\n                x(u + st, v + Δ / 2),\n                y(u + st, v + Δ / 2),\n                z(u + st, v + Δ / 2))\n            p3 = Point3D(\n                x(u + st, v - Δ / 2),\n                y(u + st, v - Δ / 2),\n                z(u + st, v - Δ / 2))\n            p4 = Point3D(\n                x(u, v - Δ / 2),\n                y(u, v - Δ / 2),\n                z(u, v - Δ / 2))\n            push!(result, [p1, p2, p3, p4])\n        end\n    end\n    return result # as an array of 3D polygons\nend\n\n# ... on a drawing\n@drawsvg begin\n    background(\"grey20\")\n    eyepoint(300, 300, 300)\n    perspective(1200)\n    setopacity(0.7)\n    sethue(\"white\")\n    setline(0.4)\n    mb = makemobius()\n    for pgon in mb\n        pin(100pgon)\n    end\nend 800 600","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"This isn’t always going to be correct - although three 3D points always define a flat face in a 2D plane, more than three points don’t always do so.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"The default action when pin() is called on a list of Point3Ds is poly(pts, fill), once the Point3Ds have been projected into 2D space as pts.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"You can also pass a gfunction. It should accept two arguments: a list of Point3Ds and a list of Points. For example, this calls Luxor's poly() function on the list of 2D points in p2 that are the projections of the Point3Ds in pgon.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"pin(pgon,\n    gfunction = (p3list, p2list) -> begin\n        poly(p2list, close=true, :fill)\n    end)","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"In this example, the gfunction draws colored circles inside each square:","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor, Colors # hide\n\nfunction makemobius()\n    x(u, v) = (1 + (v / 2 * cos(u / 2))) * cos(u)\n    y(u, v) = (1 + (v / 2 * cos(u / 2))) * sin(u)\n    z(u, v) = v / 2 * sin(u / 2)\n    w = 1\n    st = 2π / 160\n    Δ = 0.1\n    result = Array{Point3D,1}[]\n    for u in 0:st:2π-st\n        for v in -w:Δ:w\n            p1 = Point3D(\n                x(u, v + Δ / 2),\n                y(u, v + Δ / 2),\n                z(u, v + Δ / 2))\n            p2 = Point3D(\n                x(u + st, v + Δ / 2),\n                y(u + st, v + Δ / 2),\n                z(u + st, v + Δ / 2))\n            p3 = Point3D(\n                x(u + st, v - Δ / 2),\n                y(u + st, v - Δ / 2),\n                z(u + st, v - Δ / 2))\n            p4 = Point3D(\n                x(u, v - Δ / 2),\n                y(u, v - Δ / 2),\n                z(u, v - Δ / 2))\n            push!(result, [p1, p2, p3, p4])\n        end\n    end\n    return result # as an array of 3D polygons\nend\n\n# ... in a drawing\n@drawsvg begin\n    background(\"grey20\")\n    eyepoint(300, 300, 300)\n    perspective(1200)\n    mb = makemobius()\n    for (n, pgon) in enumerate(mb)\n        pin(100pgon, \n        gfunction = (p3list, p2list) -> begin\n                sethue(HSB(rand(200:300), 0.7, 0.8))\n                ellipseinquad(p2list, action=:fill)\n            end)\n    end\nend 800 600","category":"page"},{"location":"polys/#Surfaces","page":"Polygons and planes","title":"Surfaces","text":"","category":"section"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"A surface plot like the following also works quite well, mainly because each new polygon hides the ones behind it.","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"using Thebes, Luxor, Colors # hide\n@draw begin\n    background(\"grey20\")\n    helloworld() # hide\n\n    perspective(500)\n    eyepoint(500, 500, 300)\n\n    k = 30\n    xmax = 4π\n    ymax = 4π\n    st = 0.3\n\n    f(x, y) = 2(sin(x) * cos(y)) + (cos(x) * sin(y))\n\n    sethue(\"blue\")\n    setline(0.5)\n\n    for x in -xmax:st:xmax\n        for y in -ymax:st:ymax\n            sethue(HSB(360rescale(x, -xmax, xmax), 0.8, 0.8))\n            p1 = Point3D(k * x,\n                k * y,\n                k * f(x, y))\n            p2 = Point3D(k * x,\n                k * (y + st),\n                k * f(x, y + st))\n            p3 = Point3D(k * (x + st),\n                k * (y + st),\n                k * f(x + st, y + st))\n            p4 = Point3D(k * (x + st),\n                k * y,\n                k * f(x + st, y))\n            pin([p1, p2, p3, p4], gfunction=(p3s, p2s) -> begin\n                poly(p2s, close=true, :fill)\n                sethue(\"white\")\n                poly(p2s, close=true, :stroke)\n            end)\n        end\n    end\n\n    axes3D(200)\nend 800 600","category":"page"},{"location":"polys/","page":"Polygons and planes","title":"Polygons and planes","text":"note: Note\nDon't forget to check out Makie.jl for genuine 3D plotting...","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"DocTestSetup = quote\n    using Dates\nend","category":"page"},{"location":"#Introduction-to-Thebes","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"Thebes.jl is a small package that provides a few 3D wireframe tools for use with Luxor.jl, a simple 2D drawing package. You can define simple shapes in 3D, and have them projected onto a Luxor drawing.","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"note: Note\nDon't set your expectations too high! Thebes.jl merely generates a few simple 3D \"wireframe\" diagrams. For real 3D work, with solid shapes, lighting, textures, interactivity, and so on, use Makie.jl. Or spend a few months learning Blender...","category":"page"},{"location":"#Installation-and-basic-usage","page":"Introduction to Thebes","title":"Installation and basic usage","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"Install the package using the package manager at the REPL:","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"] add Thebes","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"To use Thebes, type:","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"using Thebes, Luxor","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"A quick test:","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"using Thebes\nusing Luxor\n\n@drawsvg begin\n    background(\"grey20\")\n    eyepoint(150, 150, 150)\n    perspective(700)\n    # read sphere data from a file\n    include(dirname(dirname(pathof(Thebes))) * \"/data/sphere.jl\")\n    # make a 3D object\n    S = make(sphere, \"a sphere\")\n    axes3D()\n    # resize sphere from unit coordinates\n    scaleby!(S, 150)\n\n    setopacity(0.8)\n    pin(S) # the \"project into 2D\" function\nend 800 500","category":"page"},{"location":"#Documentation","page":"Introduction to Thebes","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction to Thebes","title":"Introduction to Thebes","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are some useful tools that might help you explore the limited 3D world provided by Thebes.jl.","category":"page"},{"location":"tools/#General","page":"Tools","title":"General","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"axes3D\ncarpet\ndrawcube","category":"page"},{"location":"tools/#Thebes.axes3D","page":"Tools","title":"Thebes.axes3D","text":"axes3D(n=100)\n\nDraw labelled 3D axes at (0, 0, 0) with length n.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.carpet","page":"Tools","title":"Thebes.carpet","text":"carpet(n; kind=:circular)\n\nDraw a circular carpet centered at the origin, using current Luxor parameters.\n\nIf kind is not :circular, the carpet will be a square.\n\nPoints that can't be rendered are not included in the final shape.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.drawcube","page":"Tools","title":"Thebes.drawcube","text":"drawcube(n=10, action=:stroke)\n\nDraw a cube. drawcube(1) draws a wireframe unit cube.\n\n\n\n\n\n","category":"function"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\")\nhelloworld()\nsethue(\"grey40\")\ncarpet(400)\ndrawcube(150)\naxes3D()\nend 800 400","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are some basic geometry utility functions - some of them are analogous to their Luxor 2D counterparts.","category":"page"},{"location":"tools/#Distances","page":"Tools","title":"Distances","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"between\ndistance\nmidpoint","category":"page"},{"location":"tools/#Luxor.between","page":"Tools","title":"Luxor.between","text":"between(p1::Point3D, p2::Point3D, x=0.5)\nbetween((p1::Point3D, p2::Point3D), x=0.5)\n\nFind a point on a line between two 3D points. If x is 0.5, the returned point should be halfway between them.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Luxor.distance","page":"Tools","title":"Luxor.distance","text":"distance(p1::Point3D, p2::Point3D)\n\nReturn the distance between two points.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Luxor.midpoint","page":"Tools","title":"Luxor.midpoint","text":"midpoint(pt1::Point3D, pt2::Point3D)\n\nFind the midpoint between two points. See also between().\n\n\n\n\n\n","category":"function"},{"location":"tools/#Rotations","page":"Tools","title":"Rotations","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The task of rotating points in 3D space is given to Rotations.jl, a powerful and sophisticated package that offers many advanced functions for rotating things in 3D space. For Thebes, you'll probably only need the basics, but there's things like quaternions if you want to get fancy.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"This code draws a cyan square lying in the XY plane with a corner at the 3D origin. The square is then rotated about the Z axis by 180° and drawn in purple. Then the square is rotated again, about the X axis, by 90° and drawn in orange.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes, Rotations # hide\n\n@drawsvg begin\nbackground(\"grey20\") # hide\nsetlinejoin(\"bevel\") # hide\n\neyepoint(Point3D(150, 250, 350))\nperspective(520)\n\nfunction drawsquare(ptlist)\n    pin(ptlist, gfunction = (p3, p2) ->\n        poly(p2, :fill, close=true))\nend\n\nsquare = [\n    Point3D(0, 0, 0), \n    Point3D(100, 0, 0), \n    Point3D(100, 100, 0), \n    Point3D(0, 100, 0)\n    ]\n\nsethue(\"cyan\")\ndrawsquare(square)\n\nsethue(\"purple\")\nrotateby!(square, RotZ(π))\ndrawsquare(square)\n\nsethue(\"orange\")\nrotateby!(square, RotX(-π/2))\ndrawsquare(square)\n\naxes3D(160)\n\nend 800 400","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The most useful rotation functions are RotX(), RotY(), RotZ(), RotXY(), and RotXYZ(), which rotate around the axes. All the other permutations are available. A RotXYZ() rotation takes three angles. The right-most rotation is applied first, so RotXYZ() applies the Z rotation, followed by the Y, then followed by the X.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"You can compose two or more rotations by multiplying them together, eg RotX(π/2) * RotZ(π/4).","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The rotation functions without ! return new points or arrays of points.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"There are also functions that accept a second 3D point, the about point. The rotation  is applied around that point, rather than an axis. In the next example, the square is rotated in Z about the corner point at Point3D(100, 100, 0) and drawn in green.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes, Rotations # hide\n\n@drawsvg begin\n    background(\"grey20\")\n    setlinejoin(\"bevel\")\n\n    eyepoint(Point3D(350, 350, 350))\n    perspective(400)\n\n    function drawsquare(ptlist)\n        pin(ptlist, gfunction=(p3, p2) ->\n            poly(p2, :fill, close=true))\n    end\n\n    square = [\n        Point3D(0, 0, 0),\n        Point3D(100, 0, 0),\n        Point3D(100, 100, 0),\n        Point3D(0, 100, 0)\n    ]\n\n    sethue(\"grey40\")\n    drawsquare(square)\n\n    sethue(\"green\")\n    rotateby!(square, Point3D(100, 100, 0), RotZ(π))\n    drawsquare(square)\n\n    axes3D(160)\nend 800 400","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateby(point::Point3D, r::Rotation)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(m::Object, angleX, angleY, angleZ)\nrotateby(m::Object, pt::Point3D, angleX, angleY, angleZ)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Those with ! mutate the array of points in place. (You can't modify a single point.)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateby!(ptlist::Vector{Point3D}, r::RotXYZ{Float64})\nrotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(m::Object, angleX, angleY, angleZ)\nrotateby!(m::Object, pt::Point3D, angleX, angleY, angleZ)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"rotateX\nrotateY\nrotateZ\nrotateby!\nrotateby","category":"page"},{"location":"tools/#Thebes.rotateX","page":"Tools","title":"Thebes.rotateX","text":"rotateX(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the x axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateY","page":"Tools","title":"Thebes.rotateY","text":"rotateY(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the y axis by an angle in radians.\n\nRotations are anticlockwise when looking along axis from 0 to +axis.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateZ","page":"Tools","title":"Thebes.rotateZ","text":"rotateZ(pt3D::Point3D, rad)\n\nReturn a new point resulting from rotating the point around the z axis by an angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateby!","page":"Tools","title":"Thebes.rotateby!","text":"rotateby!(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\n\nModify a list of points by rotating each one around the x, y, and z axes by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, angleX, angleY, angleZ)\nrotateby!(ptlist::Array{Point3D, 1}, existingpt::Point3D, r::Rotation)\nrotateby!(ptlist::Array{Point3D, 1}, r::Rotation=RotXYZ{Float64})\n\nRotate each point in the list by rotation (or angleX, angleY, angleZ) around another point (or origin).\n\n\n\n\n\nrotateby!(o::Object, r::Rotation)\nrotateby!(o::Object, angleX, angleY, angleZ)\n\nRotate an object through rotation r, or around the x, y, and/or z axis by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby!(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby!(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate an object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.rotateby","page":"Tools","title":"Thebes.rotateby","text":"rotateby(pt::Point3D, angleX, angleY, angleZ)\nrotateby(ptlist::Array{Point3D, 1}, angleX, angleY, angleZ)\nrotateby(point::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, r::Rotation)\n\nReturn a new point/list of points resulting from rotating around the x, y, and z axes by angleX, angleY, angleZ.\n\nThe Z rotation is first, then the Y, then the X.\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XYZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\nrotateby(point::Point3D, about::Point3D, angleX, angleY, angleZ)\nrotateby(point::Point3D, about::Point3D, r::Rotation)\nrotateby(ptlist::Array{Point3D, 1}, about::Point3D, r::Rotation)\n\n\n\n\n\nrotateby(o::Object, angleX, angleY, angleZ)\n\nRotate a copy of the object by angleX, angleY, angleZ.\n\n\n\n\n\nrotateby(o::Object, pt::Point3D, angleX, angleY, angleZ)\nrotateby(o::Object, pt::Point3D, r::Rotation=RotXYZ(0, 0, 0))\n\nRotate a copy of the object around a point by rotation r, or angleX, angleY, angleZ.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Position-and-scale","page":"Tools","title":"Position and scale","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"You can change the position and scale of things. moveby() makes a copy, moveby!() moves the original.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In the next example, the square is first moved by -100/-100/0, then copies are moved upwards by the loop index i.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes # hide\n\n@drawsvg begin\n    background(\"grey20\")\n    setlinejoin(\"bevel\")\n\n    eyepoint(Point3D(400, 400, 500))\n    perspective(600)\n\n    function drawsquare(ptlist)\n        pin(ptlist, gfunction=(p3, p2) ->\n            poly(p2, :fill, close=true))\n    end\n\n    square = [\n        Point3D(0, 0, 0),\n        Point3D(100, 0, 0),\n        Point3D(100, 100, 0),\n        Point3D(0, 100, 0)\n    ]\n\n    sethue(\"grey40\")\n    drawsquare(square)\n\n    moveby!(square, Point3D(-100, -100, 0))\n\n    setopacity(0.6)\n    for i in 10:10:200\n        randomhue()\n        drawsquare(moveby.(square, Point3D(0, 0, i)))\n    end\n\n    axes3D(200)\nend 800 400","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"scaleby!() changes the scale of a list of points.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Luxor, Thebes # hide\n\n@drawsvg begin\n    background(\"grey20\")\n    setlinejoin(\"bevel\")\n\n    helloworld()\n\n    function drawsquare(ptlist)\n        pin(ptlist, gfunction=(p3, p2) ->\n            poly(p2, :fill, close=true))\n    end\n\n    axes3D(160)\n\n    square = [\n        Point3D(0, 0, 0),\n        Point3D(100, 0, 0),\n        Point3D(100, 100, 0),\n        Point3D(0, 100, 0)\n    ]\n\n    sethue(\"red\")\n    drawsquare(square)\n\n    sethue(\"blue\")\n    scaleby!(square, 0.5, 2, 1)\n    moveby!(square, Point3D(0, 0, 30))\n    drawsquare(square)\nend 800 350","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"moveby!\nmoveby\nscaleby!","category":"page"},{"location":"tools/#Thebes.moveby!","page":"Tools","title":"Thebes.moveby!","text":"moveby!(ptlist::Point3D, x, y, z)\nmoveby!(ptlist::Point3D, pt::Point3D)\n\nMove all points in the list by a vector.\n\n\n\n\n\nmoveby!(o::Object, x, y, z)\nmoveby!(o::Object, pt::Point3D)\n\nSet the position of object to Point3D(x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.moveby","page":"Tools","title":"Thebes.moveby","text":"moveby(pt::Point3D, d::Point3D)\n\nReturn a new point that's the result of moving a point pt by a vector d.\n\n\n\n\n\nmoveby(o::Object, x, y, z)\nmoveby(o::Object, pt::Point3D)\n\nSet the position of a copy of the object to Point3D(x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.scaleby!","page":"Tools","title":"Thebes.scaleby!","text":"scaleby!(ptlist::Array{Point3D, 1}, x, y, z)\n\nScales a list of points by multiplying by x in X, y in Y, z in Z.\n\n\n\n\n\nscaleby!(o::Object, x, y, z)\n\nScale object by x in x, y in y, and z in z.\n\n\n\n\n\nscaleby!(o::Object, d)\n\nScale object by d in x, d in y, and d in z.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Coordinates","page":"Tools","title":"Coordinates","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"A useful function is sphericaltocartesian(). This takes three values using spherical coordinates - radius, azimuthal angle, polar angle - and converts them to Cartesian coordinates - x, y, and z.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The sphericaltocartesian() function accepts three arguments: (ρ, θ, φ) - a radius, azimuthal angle, and a polar angle, in that order, and converts it to a 3D point in Cartesian coordinates.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"note: Note\nOne way to find out whether someone is a mathematician or a physicist is to ask them the order and meaning of the arguments (ρ, θ, φ) in a sphericaltocartesian() function. If ρ is the radius, is θ the azimuthal angle or the polar angle, and is φ the polar angle or the azimuthal angle? We're using the mathematicians’ order, apparently.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"This animation shows the green semicircle changing its azimuthal angle from 0° through 360° while the the orange dot changes its polar angle from 0° to 180°.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"(Image: spherical coordinates animation)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sphericaltocartesian\ncartesiantospherical\n\ndotproduct3D\ncrossproduct3D\nmagnitude\nanglebetweenvectors\nsurfacenormal\npointsperpendicular","category":"page"},{"location":"tools/#Thebes.sphericaltocartesian","page":"Tools","title":"Thebes.sphericaltocartesian","text":"sphericaltocartesian(ρ, θ, ϕ)\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ):\n\nρ is the distance from the origin (ie radius)\nθ is the azimuthal angle (the longitude) 0 is +x, π is -x, 2π is +x\nϕ is the polar angle (the latitude) 0 is North Pole, π is South Pole\n\nThere are two major conventions for spherical coordinate notation.\n\nIn physics books:\n\n(ρ, θ, φ) gives the radial distance, polar angle (latitude), and azimuthal angle (longitude)\n\nIn mathematics books:\n\n(ρ, θ , φ ) gives the radial distance, azimuthal angle (longitude), and polar angle (latitude)\n\nSo we're using the mathematics one here.\n\n\n\n\n\nsphericaltocartesian((ρ, θ, ϕ))\n\nReturn Point3D(x, y, z) corresponding to (ρ, θ, ϕ).\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.cartesiantospherical","page":"Tools","title":"Thebes.cartesiantospherical","text":"cartesiantospherical(x, y, z)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of the Point3D(x, y, z).\n\n\n\n\n\ncartesiantospherical(pt::Point3D)\n\nReturn (ρ, θ, ϕ) (radius, longitude, latitude) of pt.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.dotproduct3D","page":"Tools","title":"Thebes.dotproduct3D","text":"dotproduct3D(a::Point3D, b::Point3D)\n\nFinds the dot product of a and b\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.crossproduct3D","page":"Tools","title":"Thebes.crossproduct3D","text":"crossproduct3D(A::Point3D, B::Point3D)\n\nFind one of these.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.magnitude","page":"Tools","title":"Thebes.magnitude","text":"magnitude(a::Point3D)\n\nCalculates magnitude of a.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.anglebetweenvectors","page":"Tools","title":"Thebes.anglebetweenvectors","text":"anglebetweenvectors(v1::Point3D, v2::Point3D)\n\nCalclate the angle between two vectors.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.surfacenormal","page":"Tools","title":"Thebes.surfacenormal","text":"surfacenormal(ptlist::Array{Point3D, 1})\n\nFinds one of these.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Thebes.pointsperpendicular","page":"Tools","title":"Thebes.pointsperpendicular","text":"pointsperpendicular(p1::Point3D, p2::Point3D, radius, angles = [0, π])\n\nFind points perpendicular to a line joining p1 and p2. Points are radius units away from the line.\n\n\n\n\n\n","category":"function"},{"location":"views/","page":"Views","title":"Views","text":"DocTestSetup = quote\n    using Thebes, Luxor, Colors, Rotations\n    end","category":"page"},{"location":"views/#Views-and-perspective","page":"Views","title":"Views and perspective","text":"","category":"section"},{"location":"views/#Eyepoint-and-centerpoint","page":"Views","title":"Eyepoint and centerpoint","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Thebes takes a simple view of life. There’s a global Thebes ‘realm’ which is created when you start using it. It’s a good idea to check and/or set the current viewing parameters when you start a new Luxor document, in case you’re inheriting anything from a previous run.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"Here are the functions that control your view of the 3D scene:","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"helloworld()  \neyepoint()  \ncenterpoint()\nuppoint()\nperspective()","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"The first one is a useful one to remember: it simply resets all the viewing parameters to the default settings.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"The eyepoint() function moves the eyepoint, and centerpoint() changes the location that is the center of your view. The uppoint() function specifies a point relative to centerpoint. A line running from centerpoint to the up point defines the “up” direction.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"So, to see the side view of the helix, continued from the previous chapter, we can just lower our viewpoint a bit, from the default 100 in z down to 50:","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\nuppoint(0, 0, 100) # hide\ncenterpoint(0, 0, 50) # hide\n\nhelix = [Point3D(200cos(θ), 200sin(θ), 5θ) for θ in 0:π/48:4π]\n\nsetline(0.2)\n\neyepoint(500, 500, 50)\n\naxes3D()\nsethue(\"gold\")\nfor p in helix\n    pin(p, Point3D(0, 0, p.z))\nend\nend 800 400","category":"page"},{"location":"views/#Perspective","page":"Views","title":"Perspective","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"As yet we've seen no perspective. The default value of the perspective parameter, as returned by perspective(), is 0. This means that there's none of that foreshortening or converging of lines that head off into the distance. And if you look at a cube, it has that familiar unrealistic appearance of cubes drawn without perspective. It doesn't matter if you move the eyepoint further away, either.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\n\nhelloworld() # hide\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\nsethue(\"magenta\")\npin(50makecube())\n\nend 800 400","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"This animation views the cube and changes the perspective slowly, starting at 0, then moving from 300 up to 1400.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: perspective cube example)","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"As the value of perspective increases, the apparent magnification increases, and parallel lines start to converge. The next example shows the converging parallel lines.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor # hide\n\nhelloworld() # hide\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\n@drawsvg begin\nbackground(\"grey20\") # hide\norigin() # hide\n\neyepoint(200, 50, 100)\nperspective(150)\nsethue(\"gold\")\npts = pin(50makecube())\n\nsethue(\"grey60\")\nsetline(0.1)\nfor p1 in pts\n    for p2 in pts\n        p1 == p2 && continue\n        rule(p1, slope(p1, p2))\n    end\nend\nend 800 600","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"There are enough converging parallel lines there to give an ancient Egyptian architect nightmares.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"What are the units of the number you provide to perspective()? I don't know - it's a vague magnification constant.","category":"page"},{"location":"views/#Orbits","page":"Views","title":"Orbits","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"To fly around the scene, move the eyepoint around while looking at the center.","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"using Thebes, Luxor\nfunction frame(scene, framenumber, object)\n    background(\"skyblue\")\n    setlinejoin(\"bevel\")\n\n    setline(3.0)\n    sethue(\"grey30\")\n    carpet(500)\n    eased_n = rescale(scene.easingfunction(framenumber, 0, 1,\n        scene.framerange.stop), 0, 1, 0, 2π)\n\n    sethue(\"white\")\n    perspective(200)\n    eyepoint(200cos(eased_n), 200sin(eased_n), 40)\n    pts = pin(50object)\n\n    sethue(\"orange\")\n    setline(0.5)\n    for pair in ((1, 2), (2, 3), (3, 4), (4, 1))\n        rule(pts[first(pair)], slope(pts[first(pair)], pts[last(pair)]))\n    end\n\n    axes3D()\nend\n\nfunction makecube()\n    cube = [\n        Point3D(1,   1, -1),\n        Point3D(1,  -1, -1),\n        Point3D(-1, -1, -1),\n        Point3D(-1,  1, -1),\n        Point3D(1,   1,  1),\n        Point3D(1,  -1,  1),\n        Point3D(-1, -1,  1),\n        Point3D(-1,  1,  1)]\n    r = Point3D[]\n\n    for e in (\n        [1, 2, 3, 4, 1],\n        [5, 6, 7, 8, 5],\n        [5, 1, 2, 6, 7],\n        [7, 3, 4, 8, 5])\n        append!(r, cube[e])        \n    end\n    return r\nend\n\nfunction main()\n    w = 600\n    h = 400\n    movie1 = Movie(w, h, \"3D movie\")\n    cube = makecube()\n    d = animate(movie1,\n            Scene(movie1, (s, f)  -> frame(s, f, cube),\n                    1:150, easingfunction=easeinoutsine),\n        creategif=true,\n        framerate=20,\n        pathname=\"/tmp/orbiting-a-cube.gif\")\n    return d\nend\n\nmain()","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"(Image: animation)","category":"page"}]
}
